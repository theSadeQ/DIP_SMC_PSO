<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="7" failures="48" skipped="0" tests="178" time="29.868" timestamp="2025-09-14T20:35:57.495831+03:30" hostname="SadeQ"><testcase classname="test_sample" name="test_example" time="0.002" /><testcase classname="tests.config_validation.test_config_validation.TestUnknownKeyValidation" name="test_single_unknown_key_physics" time="0.027" /><testcase classname="tests.config_validation.test_config_validation.TestUnknownKeyValidation" name="test_multiple_unknown_keys_aggregated" time="0.018" /><testcase classname="tests.config_validation.test_config_validation.TestTypeValidation" name="test_single_wrong_type" time="0.015" /><testcase classname="tests.config_validation.test_config_validation.TestTypeValidation" name="test_multiple_wrong_types_aggregated" time="0.022" /><testcase classname="tests.config_validation.test_config_validation.TestPositiveValidation" name="test_minimal_valid_config" time="0.018" /><testcase classname="tests.config_validation.test_config_validation.TestPositiveValidation" name="test_full_config_loads" time="0.028" /><testcase classname="tests.config_validation.test_config_validation.TestMixedValidationErrors" name="test_unknown_keys_and_wrong_types_combined" time="0.018" /><testcase classname="tests.config_validation.test_config_validation.TestErrorMessageDeterminism" name="test_error_message_structure_consistent" time="0.022" /><testcase classname="tests.test_app.test_cli" name="test_app_fails_fast_on_invalid_controller" time="2.000" /><testcase classname="tests.test_app.test_cli" name="test_app_fails_on_backend_error_in_hil" time="2.034" /><testcase classname="tests.test_app.test_cli.TestDynamicsFailFast" name="test_dynamics_import_error_propagates" time="1.832" /><testcase classname="tests.test_app.test_cli.TestDynamicsFailFast" name="test_dynamics_syntax_error_propagates" time="0.008" /><testcase classname="tests.test_app.test_cli.TestControllerFailFast" name="test_invalid_controller_name_fails" time="1.858" /><testcase classname="tests.test_app.test_cli.TestControllerFailFast" name="test_controller_factory_missing_fails" time="1.944" /><testcase classname="tests.test_app.test_cli.TestUIFailFast" name="test_visualizer_import_failure_is_fatal" time="1.851" /><testcase classname="tests.test_app.test_cli.TestGeneralFailFast" name="test_no_broad_exception_handlers" time="0.003" /><testcase classname="tests.test_app.test_cli.TestGeneralFailFast" name="test_app_crashes_on_missing_numpy" time="0.562" /><testcase classname="tests.test_app.test_cli" name="test_app_fails_fast_on_invalid_fdi_config" time="1.848" /><testcase classname="tests.test_app.test_cli_save_gains" name="test_cli_save_gains_creates_file_and_logs" time="1.927" /><testcase classname="tests.test_app.test_data_export" name="test_csv_export_includes_final_state" time="0.028"><failure message="assert 1 == (10 + 1)&#10; +  where 1 = len(array([0.]))">tmp_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_csv_export_includes_final0')

    def test_csv_export_includes_final_state(tmp_path):
        """
        Verify that the exported CSV from the Streamlit app is not truncated
        and includes the final simulation state.
    
        Why: This test catches the off-by-one error where the final state vector
        was being omitted from the CSV export. We simulate the exact export logic
        from streamlit_app.py to ensure data integrity.
        """
        # 1. Setup a minimal simulation
        cfg = load_config(allow_unknown=True)
        physics = cfg.physics.model_dump()
        dyn = DIPDynamics(physics)
        gains = cfg.controller_defaults.classical_smc.gains
        ctrl = create_controller("classical_smc", gains=gains, config=cfg)
        sim_time = 0.1
        dt = 0.01
        n_steps = int(sim_time / dt)  # Should be 10 steps
    
        t_sim, x_sim, u_sim = run_simulation(
            controller=ctrl,
            dynamics_model=dyn,
            sim_time=sim_time,
            dt=dt,
            initial_state=np.zeros(6),
        )
    
        # Verify our assumptions about the simulation output
&gt;       assert len(t_sim) == n_steps + 1  # 0.0, 0.01, ..., 0.1 (11 values)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 1 == (10 + 1)
E        +  where 1 = len(array([0.]))

tests\test_app\test_data_export.py:47: AssertionError</failure></testcase><testcase classname="tests.test_app.test_data_export" name="test_csv_export_with_old_bug" time="0.001" /><testcase classname="tests.test_app.test_data_export" name="test_csv_numeric_precision" time="0.004" /><testcase classname="tests.test_app.test_streamlit_app" name="test_app_import_and_main" time="0.685" /><testcase classname="tests.test_app.test_streamlit_disturbance" name="test_disturbance_applies_in_window_and_time_advances" time="0.002" /><testcase classname="tests.test_app.test_streamlit_metrics" name="test_metrics_with_minimal_traces" time="0.001" /><testcase classname="tests.test_app.test_streamlit_metrics" name="test_metrics_tolerances_affect_settling_time" time="0.001" /><testcase classname="tests.test_app.test_ui" name="test_parse_initial_state_raises_on_unexpected_error" time="0.002" /><testcase classname="tests.test_app.test_ui" name="test_parse_initial_state_handles_empty_input" time="0.003" /><testcase classname="tests.test_app.test_visualization" name="test_visualizer_no_type_or_index_error" time="0.019" /><testcase classname="tests.test_benchmarks.test_performance" name="test_controller_compute_speed[classical_smc]" time="1.237" /><testcase classname="tests.test_benchmarks.test_performance" name="test_controller_compute_speed[sta_smc]" time="0.436" /><testcase classname="tests.test_benchmarks.test_performance" name="test_controller_compute_speed[adaptive_smc]" time="0.002"><failure message="ValueError: AdaptiveSMC requires at least 5 gains: [k1, k2, lam1, lam2, gamma]">ctrl_name = 'adaptive_smc'
config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;
benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907FAC74D0&gt;

    @pytest.mark.benchmark(group="controller.compute_control")
    @pytest.mark.parametrize("ctrl_name", CTRL_NAMES)
    def test_controller_compute_speed(ctrl_name, config, benchmark):
        """
        Measure raw compute cost of each controller's compute_control on a static state.
        The benchmark intentionally uses a constant state and stable per-call args to
        isolate the cost of the control law itself (no integration, minimal Python noise).
        """
        if create_controller is None:
            pytest.skip("Controller factory not available to instantiate controllers.")
    
        gains = _default_gains_for(ctrl_name, config)
&gt;       controller = create_controller(ctrl_name, gains=gains, config=config)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_benchmarks\test_performance.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\controllers\factory.py:1154: in create_controller
    return AdaptiveSMC(**known_params)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\controllers\adaptive_smc.py:145: in __init__
    self.validate_gains(gains)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

gains = array([5.  , 5.  , 2.  , 2.  , 1.  , 1.  , 0.01, 2.  ])

    @staticmethod
    def validate_gains(gains: List[float]) -&gt; None:
        """
        Validate that a suitable gain sequence has been provided.
    
        The adaptive sliding–mode controller uses exactly five gains
        (k1, k2, λ1, λ2, γ) for its sliding surface and adaptation law.
        Additional gains may be supplied for forward compatibility
        (they will be ignored), but fewer than five gains is considered
        an error.
    
        Raises
        ------
        ValueError
            If ``gains`` has fewer than five elements.
        """
        if not isinstance(gains, (list, tuple)) or len(gains) &lt; 5:
&gt;           raise ValueError(
                "AdaptiveSMC requires at least 5 gains: [k1, k2, lam1, lam2, gamma]"
            )
E           ValueError: AdaptiveSMC requires at least 5 gains: [k1, k2, lam1, lam2, gamma]

src\controllers\adaptive_smc.py:229: ValueError</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_full_simulation_throughput[classical_smc]" time="0.002"><failure message="KeyError: 'classical_smc'">ctrl_name = 'classical_smc'
config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907F5D68B0&gt;

    @pytest.mark.benchmark(group="simulation.throughput")
    @pytest.mark.parametrize("ctrl_name", CTRL_NAMES)
    def test_full_simulation_throughput(ctrl_name, config, full_dynamics, benchmark):
        """
        Time the end-to-end batch simulation for each controller over 1s of sim time
        with 50 particles. Uses the Numba batch kernel if available.
        """
        # Simulation shape
        B = 50
        dt = float(config.simulation.dt)
        duration = 1.0
        N = int(np.ceil(duration / dt))
    
        # Gains per particle
        g = _default_gains_for(ctrl_name, config)
        gains_b = np.tile(g, (B, 1))
    
        # Initial states per particle (slight randomization for realism)
        rng = np.random.default_rng(0)
        x0 = np.zeros((B, 6), dtype=float)
        x0[:, 1] = rng.normal(0.05, 0.01, size=B)  # theta1
        x0[:, 2] = rng.normal(-0.04, 0.01, size=B) # theta2
    
        # Controller mode for the numba kernel
        mode = _controller_mode(ctrl_name)
    
        # Choose the callable to benchmark
        if _simulate_fallback is not None:
            # Internal kernel signature: (gains_b, x0_b, N, dt, params, u_max, controller_mode)
            params = full_dynamics.params  # FullDIPParams instance
            try:
                u_max = getattr(config.controllers[ctrl_name], "max_force", None)
            except Exception:
                u_max = None
            if u_max is None:
                u_max = 150.0
    
            def _call():
                return _simulate_fallback(gains_b, x0, N, dt, params, float(u_max), int(mode))
            result = benchmark(_call)
            # Ensure arrays returned (x, u, sigma, ctrl_states)
            assert isinstance(result, tuple) and len(result) == 4
        else:
            # Public API path: use the high‑level batch simulator
            # Construct a controller factory for this controller
            def controller_factory(particle_gains):
                return create_controller(ctrl_name, config=config, gains=particle_gains)
    
            def _call():
                return _simulate_batch(
                    controller_factory=controller_factory,
                    particles=gains_b,
                    initial_state=x0,
                    sim_time=duration,
                    dt=dt,
                    u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                )
&gt;           result = benchmark(_call)
                     ^^^^^^^^^^^^^^^^

tests\test_benchmarks\test_performance.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:156: in __call__
    return self._raw(function_to_benchmark, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:180: in _raw
    duration, iterations, loops_range = self._calibrate_timer(runner)
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:318: in _calibrate_timer
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _call():
        return _simulate_batch(
            controller_factory=controller_factory,
            particles=gains_b,
            initial_state=x0,
            sim_time=duration,
            dt=dt,
&gt;           u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
E       KeyError: 'classical_smc'

tests\test_benchmarks\test_performance.py:161: KeyError</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_full_simulation_throughput[sta_smc]" time="0.002"><failure message="KeyError: 'sta_smc'">ctrl_name = 'sta_smc'
config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907F5D76F0&gt;

    @pytest.mark.benchmark(group="simulation.throughput")
    @pytest.mark.parametrize("ctrl_name", CTRL_NAMES)
    def test_full_simulation_throughput(ctrl_name, config, full_dynamics, benchmark):
        """
        Time the end-to-end batch simulation for each controller over 1s of sim time
        with 50 particles. Uses the Numba batch kernel if available.
        """
        # Simulation shape
        B = 50
        dt = float(config.simulation.dt)
        duration = 1.0
        N = int(np.ceil(duration / dt))
    
        # Gains per particle
        g = _default_gains_for(ctrl_name, config)
        gains_b = np.tile(g, (B, 1))
    
        # Initial states per particle (slight randomization for realism)
        rng = np.random.default_rng(0)
        x0 = np.zeros((B, 6), dtype=float)
        x0[:, 1] = rng.normal(0.05, 0.01, size=B)  # theta1
        x0[:, 2] = rng.normal(-0.04, 0.01, size=B) # theta2
    
        # Controller mode for the numba kernel
        mode = _controller_mode(ctrl_name)
    
        # Choose the callable to benchmark
        if _simulate_fallback is not None:
            # Internal kernel signature: (gains_b, x0_b, N, dt, params, u_max, controller_mode)
            params = full_dynamics.params  # FullDIPParams instance
            try:
                u_max = getattr(config.controllers[ctrl_name], "max_force", None)
            except Exception:
                u_max = None
            if u_max is None:
                u_max = 150.0
    
            def _call():
                return _simulate_fallback(gains_b, x0, N, dt, params, float(u_max), int(mode))
            result = benchmark(_call)
            # Ensure arrays returned (x, u, sigma, ctrl_states)
            assert isinstance(result, tuple) and len(result) == 4
        else:
            # Public API path: use the high‑level batch simulator
            # Construct a controller factory for this controller
            def controller_factory(particle_gains):
                return create_controller(ctrl_name, config=config, gains=particle_gains)
    
            def _call():
                return _simulate_batch(
                    controller_factory=controller_factory,
                    particles=gains_b,
                    initial_state=x0,
                    sim_time=duration,
                    dt=dt,
                    u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                )
&gt;           result = benchmark(_call)
                     ^^^^^^^^^^^^^^^^

tests\test_benchmarks\test_performance.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:156: in __call__
    return self._raw(function_to_benchmark, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:180: in _raw
    duration, iterations, loops_range = self._calibrate_timer(runner)
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:318: in _calibrate_timer
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _call():
        return _simulate_batch(
            controller_factory=controller_factory,
            particles=gains_b,
            initial_state=x0,
            sim_time=duration,
            dt=dt,
&gt;           u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
E       KeyError: 'sta_smc'

tests\test_benchmarks\test_performance.py:161: KeyError</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_full_simulation_throughput[adaptive_smc]" time="0.001"><failure message="KeyError: 'adaptive_smc'">ctrl_name = 'adaptive_smc'
config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907F5D7BB0&gt;

    @pytest.mark.benchmark(group="simulation.throughput")
    @pytest.mark.parametrize("ctrl_name", CTRL_NAMES)
    def test_full_simulation_throughput(ctrl_name, config, full_dynamics, benchmark):
        """
        Time the end-to-end batch simulation for each controller over 1s of sim time
        with 50 particles. Uses the Numba batch kernel if available.
        """
        # Simulation shape
        B = 50
        dt = float(config.simulation.dt)
        duration = 1.0
        N = int(np.ceil(duration / dt))
    
        # Gains per particle
        g = _default_gains_for(ctrl_name, config)
        gains_b = np.tile(g, (B, 1))
    
        # Initial states per particle (slight randomization for realism)
        rng = np.random.default_rng(0)
        x0 = np.zeros((B, 6), dtype=float)
        x0[:, 1] = rng.normal(0.05, 0.01, size=B)  # theta1
        x0[:, 2] = rng.normal(-0.04, 0.01, size=B) # theta2
    
        # Controller mode for the numba kernel
        mode = _controller_mode(ctrl_name)
    
        # Choose the callable to benchmark
        if _simulate_fallback is not None:
            # Internal kernel signature: (gains_b, x0_b, N, dt, params, u_max, controller_mode)
            params = full_dynamics.params  # FullDIPParams instance
            try:
                u_max = getattr(config.controllers[ctrl_name], "max_force", None)
            except Exception:
                u_max = None
            if u_max is None:
                u_max = 150.0
    
            def _call():
                return _simulate_fallback(gains_b, x0, N, dt, params, float(u_max), int(mode))
            result = benchmark(_call)
            # Ensure arrays returned (x, u, sigma, ctrl_states)
            assert isinstance(result, tuple) and len(result) == 4
        else:
            # Public API path: use the high‑level batch simulator
            # Construct a controller factory for this controller
            def controller_factory(particle_gains):
                return create_controller(ctrl_name, config=config, gains=particle_gains)
    
            def _call():
                return _simulate_batch(
                    controller_factory=controller_factory,
                    particles=gains_b,
                    initial_state=x0,
                    sim_time=duration,
                    dt=dt,
                    u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                )
&gt;           result = benchmark(_call)
                     ^^^^^^^^^^^^^^^^

tests\test_benchmarks\test_performance.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:156: in __call__
    return self._raw(function_to_benchmark, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:180: in _raw
    duration, iterations, loops_range = self._calibrate_timer(runner)
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:318: in _calibrate_timer
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _call():
        return _simulate_batch(
            controller_factory=controller_factory,
            particles=gains_b,
            initial_state=x0,
            sim_time=duration,
            dt=dt,
&gt;           u_max=float(getattr(config.controllers[ctrl_name], "max_force", 150.0)),
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
E       KeyError: 'adaptive_smc'

tests\test_benchmarks\test_performance.py:161: KeyError</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_classical_smc_convergence" time="0.004"><failure message="RuntimeWarning: Mean of empty slice.">benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907F5D7950&gt;
physics_cfg = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    @pytest.mark.benchmark(group="controller_convergence")
    def test_classical_smc_convergence(benchmark, physics_cfg):
&gt;       result = benchmark.pedantic(
            _batch_convergence_time,
            kwargs=dict(
                controller_cls=ClassicalSMC,
                physics_params=physics_cfg,
                gains=[10.0, 8.0, 5.0, 4.0, 50.0, 1.0],
            ),
            iterations=5,
            rounds=3,
        )

tests\test_benchmarks\test_performance.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:167: in pedantic
    return self._raw_pedantic(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:256: in _raw_pedantic
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
tests\test_benchmarks\test_performance.py:258: in _batch_convergence_time
    rms_per_batch = np.sqrt(np.mean(controls_b**2, axis=1))
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\numpy\_core\fromnumeric.py:3860: in mean
    return _methods._mean(a, axis=axis, dtype=dtype,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

a = array([], shape=(50, 0), dtype=float64), axis = 1, dtype = None, out = None
keepdims = False

    def _mean(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
        arr = asanyarray(a)
    
        is_float16_result = False
    
        rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
        if rcount == 0 if where is True else umr_any(rcount == 0, axis=None):
&gt;           warnings.warn("Mean of empty slice.", RuntimeWarning, stacklevel=2)
E           RuntimeWarning: Mean of empty slice.

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\numpy\_core\_methods.py:124: RuntimeWarning</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_sta_smc_convergence[False]" time="0.003"><failure message="RuntimeWarning: Mean of empty slice.">benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002907F5D7BB0&gt;
physics_cfg = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;
use_ueq = False

    @pytest.mark.parametrize("use_ueq", [False, True])
    #@pytest.mark.usefixtures("long_simulation_config")
    @pytest.mark.benchmark(group="controller_convergence")
    def test_sta_smc_convergence(benchmark, physics_cfg, use_ueq):
        """
        Super-Twisting SMC should converge quickly without large σ overshoot
        with corrected sign conventions and validated gains.
        """
&gt;       result = benchmark.pedantic(
            _batch_convergence_time,
            kwargs=dict(
                controller_cls=SuperTwistingSMC,
                physics_params=physics_cfg,
                # These are the validated gains for the corrected controller
                gains=[1.18495, 47.7040, 1.0807, 7.4019, 46.9200, 0.6699],
                # Ensure fast convergence from a consistent, perturbed start
                initial_state=np.array([0.0, 0.1, 0.1, 0.0, 0.0, 0.0]),
                use_ueq=use_ueq,
            ),
            iterations=5,
            rounds=3,
        )

tests\test_benchmarks\test_performance.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:167: in pedantic
    return self._raw_pedantic(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:256: in _raw_pedantic
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
tests\test_benchmarks\test_performance.py:258: in _batch_convergence_time
    rms_per_batch = np.sqrt(np.mean(controls_b**2, axis=1))
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\numpy\_core\fromnumeric.py:3860: in mean
    return _methods._mean(a, axis=axis, dtype=dtype,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

a = array([], shape=(50, 0), dtype=float64), axis = 1, dtype = None, out = None
keepdims = False

    def _mean(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
        arr = asanyarray(a)
    
        is_float16_result = False
    
        rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
        if rcount == 0 if where is True else umr_any(rcount == 0, axis=None):
&gt;           warnings.warn("Mean of empty slice.", RuntimeWarning, stacklevel=2)
E           RuntimeWarning: Mean of empty slice.

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\numpy\_core\_methods.py:124: RuntimeWarning</failure></testcase><testcase classname="tests.test_benchmarks.test_performance" name="test_sta_smc_convergence[True]" time="0.002"><failure message="pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig&#10;cart_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;gravity&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;cart_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint1_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint2_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing">benchmark = &lt;pytest_benchmark.fixture.BenchmarkFixture object at 0x000002900E3BC8A0&gt;
physics_cfg = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;
use_ueq = True

    @pytest.mark.parametrize("use_ueq", [False, True])
    #@pytest.mark.usefixtures("long_simulation_config")
    @pytest.mark.benchmark(group="controller_convergence")
    def test_sta_smc_convergence(benchmark, physics_cfg, use_ueq):
        """
        Super-Twisting SMC should converge quickly without large σ overshoot
        with corrected sign conventions and validated gains.
        """
&gt;       result = benchmark.pedantic(
            _batch_convergence_time,
            kwargs=dict(
                controller_cls=SuperTwistingSMC,
                physics_params=physics_cfg,
                # These are the validated gains for the corrected controller
                gains=[1.18495, 47.7040, 1.0807, 7.4019, 46.9200, 0.6699],
                # Ensure fast convergence from a consistent, perturbed start
                initial_state=np.array([0.0, 0.1, 0.1, 0.0, 0.0, 0.0]),
                use_ueq=use_ueq,
            ),
            iterations=5,
            rounds=3,
        )

tests\test_benchmarks\test_performance.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:167: in pedantic
    return self._raw_pedantic(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:256: in _raw_pedantic
    duration = runner(loops_range)
               ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pytest_benchmark\fixture.py:109: in runner
    function_to_benchmark(*args, **kwargs)
tests\test_benchmarks\test_performance.py:231: in _batch_convergence_time
    t, states_b, controls_b, sigma_b = simulate_system_batch(
src\core\vector_sim.py:326: in simulate_system_batch
    ctrl = controller_factory(part_arr[j])
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests\test_benchmarks\test_performance.py:193: in controller_factory
    kwargs_controller['dynamics_model'] = DoubleInvertedPendulum(physics_params)
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.core.dynamics.DoubleInvertedPendulum object at 0x000002907FAC6990&gt;
params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def __init__(self, params: Any):
        """
        Initialize the simplified double inverted pendulum dynamics model.
    
        Parameters
        ----------
        params : Any
            A physics configuration specifying the system constants.  This
            must either be an instance of :class:`src.config.PhysicsConfig`
            or a mapping with the same keys.  Passing a mapping will
            attempt to construct a :class:`PhysicsConfig` to ensure the
            values are validated.  Any failure to import or construct
            the configuration will propagate an exception.
        """
        # PhysicsConfig is imported at the module level.  Avoid re‑importing
        # it here to prevent circular import issues when running tests
        # under alternative import paths.  The top‑level import ensures
        # PhysicsConfig is available.
    
        if params is None:
            raise ValueError("Physics parameters must not be None")
    
        # Determine whether the input is already a validated PhysicsConfig.
        if isinstance(params, PhysicsConfig):
            phys_cfg = params
        else:
            # Extract a plain dictionary from the input.  Accept Pydantic‑like
            # objects that implement model_dump(), plain dicts, or objects
            # that can be converted via dict().  Raise if conversion is
            # impossible so that invalid inputs are not silently accepted.
            if hasattr(params, "model_dump"):
                param_dict = params.model_dump()
            elif isinstance(params, dict):
                param_dict = params
            else:
                try:
                    param_dict = dict(params)
                except Exception:
                    raise TypeError(
                        "Physics parameters must be a PhysicsConfig or dict‑like mapping"
                    )
            # Construct a PhysicsConfig from the dictionary.  This will
            # perform full Pydantic validation and raise on invalid or
            # missing fields.
&gt;           phys_cfg = PhysicsConfig(**param_dict)  # type: ignore[arg-type]
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig
E           cart_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           gravity
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           cart_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint1_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint2_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

src\core\dynamics.py:449: ValidationError</failure></testcase><testcase classname="tests.test_benchmarks.test_statistical_benchmarks" name="test_statistical_harness_sample_size_and_ci" time="0.002"><failure message="TypeError: simulate_system_batch() takes 0 positional arguments but 2 positional arguments (and 3 keyword-only arguments) were given">controller_factory = &lt;function controller_factory at 0x000002907EF863E0&gt;
cfg = ConfigSchema(global_seed=1, controller_defaults=ControllersConfig(classical_smc=None, sta_smc=None, adaptive_smc=None,...lant_port=9000, controller_ip='127.0.0.1', controller_port=9001, extra_latency_ms=0.0, sensor_noise_std=0.0), fdi=None)
n_trials = 30, seed = 42, randomise_physics = False, noise_std = 0.0

    def run_trials(
        controller_factory: Callable[[np.ndarray], Any],
        cfg: Any,
        n_trials: int = 30,
        seed: int = 1234,
        randomise_physics: bool = False,
        noise_std: float = 0.0,
    ) -&gt; Tuple[List[Dict[str, float]], Dict[str, Tuple[float, float]]]:
        """Run multiple simulations and return per‑trial metrics with confidence intervals.
    
        The function executes ``n_trials`` independent simulations of the
        double inverted pendulum under the supplied controller factory and
        configuration.  For each trial it collects performance metrics and
        computes a 95 % confidence interval for the mean of each metric.  A
        sample size of at least 25–30 trials is recommended to invoke the
        Central Limit Theorem for skewed distributions【559538113951338†L77-L84】.
    
        Parameters
        ----------
        controller_factory : Callable[[np.ndarray], Any]
            Factory function that returns a controller instance when provided
            with a gain vector.  The returned controller must define an
            ``n_gains`` attribute and may define ``max_force``.
        cfg : Any
            Full configuration object (e.g., ``ConfigSchema``) supplying
            physics and simulation parameters.  Only ``simulation.duration``
            and ``simulation.dt`` are required by this harness.
        n_trials : int, optional
            Number of independent trials to run.  Defaults to 30.
        seed : int, optional
            Base random seed used to initialise each trial.  Individual trials
            draw their seeds from a NumPy generator seeded with this value.
        randomise_physics : bool, optional
            When True, randomly perturb the physical parameters between trials.
            Not implemented in this harness; reserved for future use.
        noise_std : float, optional
            Standard deviation of additive Gaussian noise applied to the state
            trajectories before metric computation.
    
        Returns
        -------
        list of dict, dict
            A list containing the raw metrics for each trial and a dictionary
            mapping metric names to tuples ``(mean, ci)`` where ``ci`` is
            half the width of the 95 % confidence interval.
        """
        rng = np.random.default_rng(int(seed))
        metrics_list: List[Dict[str, float]] = []
        # Determine maximum allowed control force from a reference controller
        ref_ctrl = controller_factory(np.zeros(controller_factory.n_gains))
        max_force = getattr(ref_ctrl, "max_force", 150.0)
        for _ in range(int(n_trials)):
            trial_seed = int(rng.integers(0, 2**32 - 1))
            # Execute vectorised batch simulation for a single controller
            try:
&gt;               t, x_b, u_b, sigma_b = simulate_system_batch(
                    controller_factory,
                    np.array([np.zeros(controller_factory.n_gains)], dtype=float),
                    sim_time=cfg.simulation.duration,
                    dt=cfg.simulation.dt,
                    u_max=max_force,
                    seed=trial_seed,
                )
E               TypeError: simulate_system_batch() takes 0 positional arguments but 2 positional arguments (and 4 keyword-only arguments) were given

src\benchmarks\statistical_benchmarks.py:156: TypeError

During handling of the above exception, another exception occurred:

    def test_statistical_harness_sample_size_and_ci() -&gt; None:
        """run_trials should return n_trials metrics and narrower CIs for larger n."""
        cfg = _make_cfg()
        with patch('src.core.vector_sim.simulate_system_batch', dummy_simulate_system_batch_stat):
            # 30 trials
&gt;           metrics30, ci30 = run_trials(
                controller_factory=controller_factory,
                cfg=cfg,
                n_trials=30,
                seed=42,
                randomise_physics=False,
                noise_std=0.0,
            )

tests\test_benchmarks\test_statistical_benchmarks.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

controller_factory = &lt;function controller_factory at 0x000002907EF863E0&gt;
cfg = ConfigSchema(global_seed=1, controller_defaults=ControllersConfig(classical_smc=None, sta_smc=None, adaptive_smc=None,...lant_port=9000, controller_ip='127.0.0.1', controller_port=9001, extra_latency_ms=0.0, sensor_noise_std=0.0), fdi=None)
n_trials = 30, seed = 42, randomise_physics = False, noise_std = 0.0

    def run_trials(
        controller_factory: Callable[[np.ndarray], Any],
        cfg: Any,
        n_trials: int = 30,
        seed: int = 1234,
        randomise_physics: bool = False,
        noise_std: float = 0.0,
    ) -&gt; Tuple[List[Dict[str, float]], Dict[str, Tuple[float, float]]]:
        """Run multiple simulations and return per‑trial metrics with confidence intervals.
    
        The function executes ``n_trials`` independent simulations of the
        double inverted pendulum under the supplied controller factory and
        configuration.  For each trial it collects performance metrics and
        computes a 95 % confidence interval for the mean of each metric.  A
        sample size of at least 25–30 trials is recommended to invoke the
        Central Limit Theorem for skewed distributions【559538113951338†L77-L84】.
    
        Parameters
        ----------
        controller_factory : Callable[[np.ndarray], Any]
            Factory function that returns a controller instance when provided
            with a gain vector.  The returned controller must define an
            ``n_gains`` attribute and may define ``max_force``.
        cfg : Any
            Full configuration object (e.g., ``ConfigSchema``) supplying
            physics and simulation parameters.  Only ``simulation.duration``
            and ``simulation.dt`` are required by this harness.
        n_trials : int, optional
            Number of independent trials to run.  Defaults to 30.
        seed : int, optional
            Base random seed used to initialise each trial.  Individual trials
            draw their seeds from a NumPy generator seeded with this value.
        randomise_physics : bool, optional
            When True, randomly perturb the physical parameters between trials.
            Not implemented in this harness; reserved for future use.
        noise_std : float, optional
            Standard deviation of additive Gaussian noise applied to the state
            trajectories before metric computation.
    
        Returns
        -------
        list of dict, dict
            A list containing the raw metrics for each trial and a dictionary
            mapping metric names to tuples ``(mean, ci)`` where ``ci`` is
            half the width of the 95 % confidence interval.
        """
        rng = np.random.default_rng(int(seed))
        metrics_list: List[Dict[str, float]] = []
        # Determine maximum allowed control force from a reference controller
        ref_ctrl = controller_factory(np.zeros(controller_factory.n_gains))
        max_force = getattr(ref_ctrl, "max_force", 150.0)
        for _ in range(int(n_trials)):
            trial_seed = int(rng.integers(0, 2**32 - 1))
            # Execute vectorised batch simulation for a single controller
            try:
                t, x_b, u_b, sigma_b = simulate_system_batch(
                    controller_factory,
                    np.array([np.zeros(controller_factory.n_gains)], dtype=float),
                    sim_time=cfg.simulation.duration,
                    dt=cfg.simulation.dt,
                    u_max=max_force,
                    seed=trial_seed,
                )
            except TypeError:
                # Fallback to signature without dt
&gt;               t, x_b, u_b, sigma_b = simulate_system_batch(
                    controller_factory,
                    np.array([np.zeros(controller_factory.n_gains)], dtype=float),
                    sim_time=cfg.simulation.duration,
                    u_max=max_force,
                    seed=trial_seed,
                )
E               TypeError: simulate_system_batch() takes 0 positional arguments but 2 positional arguments (and 3 keyword-only arguments) were given

src\benchmarks\statistical_benchmarks.py:166: TypeError</failure></testcase><testcase classname="tests.test_config.test_unknown_params_modes" name="test_strict_mode_rejects_unknown_keys" time="0.020" /><testcase classname="tests.test_config.test_unknown_params_modes" name="test_permissive_mode_collects_unknown_params" time="0.024" /><testcase classname="tests.test_controllers.test_adaptive_smc" name="test_adaptive_smc_gains_are_configurable" time="0.001"><error message="failed on setup with &quot;AttributeError: 'dict' object has no attribute 'adaptive_smc'&quot;">config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;

    @pytest.fixture
    def adaptive_controller(config):
        # Build via factory so we exercise the config-&gt;factory-&gt;controller path
&gt;       gains = config.controller_defaults.adaptive_smc.gains
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'adaptive_smc'

tests\test_controllers\test_adaptive_smc.py:21: AttributeError</error></testcase><testcase classname="tests.test_controllers.test_adaptive_smc" name="test_adaptive_gain_increases_on_large_error" time="0.001"><error message="failed on setup with &quot;AttributeError: 'dict' object has no attribute 'adaptive_smc'&quot;">config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;

    @pytest.fixture
    def adaptive_controller(config):
        # Build via factory so we exercise the config-&gt;factory-&gt;controller path
&gt;       gains = config.controller_defaults.adaptive_smc.gains
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'adaptive_smc'

tests\test_controllers\test_adaptive_smc.py:21: AttributeError</error></testcase><testcase classname="tests.test_controllers.test_adaptive_smc" name="test_gain_remains_bounded_under_chattering" time="0.001"><error message="failed on setup with &quot;AttributeError: 'dict' object has no attribute 'adaptive_smc'&quot;">config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;

    @pytest.fixture
    def adaptive_controller(config):
        # Build via factory so we exercise the config-&gt;factory-&gt;controller path
&gt;       gains = config.controller_defaults.adaptive_smc.gains
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'adaptive_smc'

tests\test_controllers\test_adaptive_smc.py:21: AttributeError</error></testcase><testcase classname="tests.test_controllers.test_classical_smc" name="test_equivalent_control_returns_zero_without_dynamics" time="0.001" /><testcase classname="tests.test_controllers.test_classical_smc" name="test_equivalent_control_non_zero_with_custom_dynamics" time="0.001" /><testcase classname="tests.test_controllers.test_classical_smc" name="test_compute_control_is_saturated_and_returns_correct_types" time="0.001" /><testcase classname="tests.test_controllers.test_controller_basics" name="test_sta_smc_state_vars_signature" time="0.002"><failure message="RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.">def test_sta_smc_state_vars_signature() -&gt; None:
        """compute_control should return state_vars as a tuple of two floats."""
        # Provide six gains to fully specify the sliding surface
        gains = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
        ctrl = SuperTwistingSMC(gains=gains, dt=0.01, max_force=10.0, boundary_layer=0.01)
        state = np.zeros(6, dtype=float)
        state_vars = ctrl.initialize_state()
        history = ctrl.initialize_history()
&gt;       u, next_state_vars, hist = ctrl.compute_control(state, state_vars, history)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_controllers\test_controller_basics.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\controllers\sta_smc.py:373: in compute_control
    sgn_sigma = saturate(sigma, self.boundary_layer, method=self.switch_method)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sigma = np.float64(0.0), epsilon = 0.01, method = 'linear'

    def saturate(
        sigma: float | np.ndarray,
        epsilon: float,
        method: Literal["tanh", "linear"] = "tanh",
    ) -&gt; float | np.ndarray:
        """Continuous approximation of sign(sigma) within a boundary layer.
    
        Args:
            sigma: Sliding surface value(s).
            epsilon: Boundary-layer half-width in σ-space (must be &gt; 0).  # ε is the half-width in σ-space.
            method: "tanh" (default) uses tanh(sigma/epsilon);
                    "linear" uses clip(sigma/epsilon, -1, 1).
        Returns:
            Same shape as `sigma`.
    
        Notes
        -----
        The boundary layer width ``epsilon`` should be chosen based on the
        expected amplitude of measurement noise and the desired steady‑state
        accuracy.  A larger ``epsilon`` reduces chattering but introduces
        a finite steady‑state error; conversely, a smaller ``epsilon`` reduces
        error but may increase high‑frequency switching【538884328193976†L412-L423】.
    
        Raises:
            ValueError
                If ``epsilon &lt;= 0`` or an unknown ``method`` is provided.
        """
        if epsilon &lt;= 0:
            raise ValueError("boundary layer epsilon must be positive")
        s = np.asarray(sigma, dtype=float) / float(epsilon)
        if method == "tanh":
            return np.tanh(s)
        if method == "linear":
            # Warn users that the linear saturation approximates sign(sigma) poorly
            # near zero.  A piecewise‑linear approximation yields a sharp transition
            # at the boundary layer and can introduce larger steady‑state errors.
            # Sliding‑mode control theory recommends smooth approximations such
            # as tanh to mitigate chattering【676964782857750†L146-L149】.
            import warnings
&gt;           warnings.warn(
                "The 'linear' switching method implements a piecewise‑linear saturation, "
                "which approximates the sign function poorly near zero and can degrade "
                "chattering performance.  Consider using 'tanh' for smoother control.",
                RuntimeWarning,
            )
E           RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.

src\utils\control_primitives.py:145: RuntimeWarning</failure></testcase><testcase classname="tests.test_controllers.test_controller_basics" name="test_create_controller_types[classical_smc-ClassicalSMC-gains0]" time="0.002" /><testcase classname="tests.test_controllers.test_controller_basics" name="test_create_controller_types[sta_smc-SuperTwistingSMC-gains1]" time="0.002" /><testcase classname="tests.test_controllers.test_controller_basics" name="test_create_controller_types[adaptive_smc-AdaptiveSMC-gains2]" time="0.002" /><testcase classname="tests.test_controllers.test_controller_basics" name="test_create_controller_invalid_name" time="0.030" /><testcase classname="tests.test_controllers.test_factory_deprecations" name="test_deprecated_param_is_mapped_with_warning" time="0.001" /><testcase classname="tests.test_controllers.test_factory_deprecations" name="test_unknown_keys_strict_vs_permissive" time="0.002" /><testcase classname="tests.test_controllers.test_factory_dynamics_consolidated" name="test_factory_and_dynamics_core" time="0.002"><failure message="assert 'Available: alpha, beta, zeta' in &quot;Controller 'does_not_exist' is not a recognized type&quot;&#10; +  where &quot;Controller 'does_not_exist' is not a recognized type&quot; = str(ValueError(&quot;Controller 'does_not_exist' is not a recognized type&quot;))&#10; +    where ValueError(&quot;Controller 'does_not_exist' is not a recognized type&quot;) = &lt;ExceptionInfo ValueError(&quot;Controller 'does_not_exist' is not a recognized type&quot;) tblen=2&gt;.value">monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002907F443530&gt;

    def test_factory_and_dynamics_core(monkeypatch):
        # a) unknown controller lists available (sorted)
        class Dyn:
            def __init__(self, physics): pass
        monkeypatch.setattr(factory, "DoubleInvertedPendulum", Dyn, raising=False)
        class CfgA:
            class Sim: use_full_dynamics = False; dt = 0.01
            simulation = Sim(); controllers = {"zeta": {}, "alpha": {}, "beta": {}}
            controller_defaults = {}
        with pytest.raises(ValueError) as e1:
            factory.create_controller("does_not_exist", config=CfgA(), gains=None)
&gt;       assert "Available: alpha, beta, zeta" in str(e1.value)
E       assert 'Available: alpha, beta, zeta' in "Controller 'does_not_exist' is not a recognized type"
E        +  where "Controller 'does_not_exist' is not a recognized type" = str(ValueError("Controller 'does_not_exist' is not a recognized type"))
E        +    where ValueError("Controller 'does_not_exist' is not a recognized type") = &lt;ExceptionInfo ValueError("Controller 'does_not_exist' is not a recognized type") tblen=2&gt;.value

tests\test_controllers\test_factory_dynamics_consolidated.py:16: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_dt_inherits_from_simulation_with_warning" time="0.002" /><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_max_force_defaults_with_warning" time="0.002" /><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_invalid_dt_raises[0.0]" time="0.001" /><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_invalid_dt_raises[-0.001]" time="0.001" /><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_invalid_max_force_raises[0.0]" time="0.002" /><testcase classname="tests.test_controllers.test_factory_shared_params" name="test_invalid_max_force_raises[-5.0]" time="0.001" /><testcase classname="tests.test_controllers.test_hybrid_adaptation_unit" name="test_adaptation_slows_as_s_decays" time="0.101" /><testcase classname="tests.test_controllers.test_hybrid_adaptation_unit" name="test_no_gain_growth_when_hard_saturated_and_near_zero" time="0.002" /><testcase classname="tests.test_controllers.test_hybrid_adaptation_unit" name="test_numerical_safety_prevents_inf_nan" time="0.001" /><testcase classname="tests.test_controllers.test_hybrid_adaptation_unit" name="test_taper_factor_computation" time="0.001" /><testcase classname="tests.test_controllers.test_hybrid_adaptation_unit" name="test_gain_leak_prevents_indefinite_growth" time="0.002" /><testcase classname="tests.test_controllers.test_hybrid_adaptive_sta_smc" name="test_stabilization_and_adaptation" time="0.002"><error message="failed on setup with &quot;src.controllers.factory.FactoryConfigurationError: Controller 'hybrid_adaptive_sta_smc' not found in config.controllers. Available: SMC&quot;">config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;

    @pytest.fixture
    def hybrid_controller(config) -&gt; Any:
        # Conservative, 1 kHz control, modest adaptation
        # Create controller configuration
        ctrl_cfg = {
            "gains": [5.0, 3.0, 5.0, 1.8],  # [c1, λ1, c2, λ2]
            "max_force": 150.0,
            "dt": 0.001,
            "k1_init": 6.0,
            "k2_init": 1.2,
            "gamma1": 0.8,
            "gamma2": 0.4,
            "dead_zone": 0.02,
        }
&gt;       return build_controller(
            "hybrid_adaptive_sta_smc",
            ctrl_cfg,
            allow_unknown=True,
            config=config
        )

tests\test_controllers\test_hybrid_adaptive_sta_smc.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\controllers\factory.py:511: in build_controller
    return _legacy_create_controller(name, cfg, config, gains, allow_unknown)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

ctrl_name = 'hybrid_adaptive_sta_smc'
ctrl_cfg = {'dead_zone': 0.02, 'dt': 0.001, 'gains': [5.0, 3.0, 5.0, 1.8], 'gamma1': 0.8, ...}
config = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg object at 0x000002907FAC6FD0&gt;
gains = None, allow_unknown = True

    def _legacy_create_controller(
        ctrl_name: str,
        ctrl_cfg: Any,
        config: Optional[Any],
        gains: Optional[List[float]],
        allow_unknown: bool
    ) -&gt; Any:
        """Legacy controller creation for backward compatibility."""
        # Load config if needed
        if config is None:
            if load_config is None:
                raise RuntimeError("No configuration loader available. Provide 'config' explicitly.")
            config = load_config("config.yaml")
    
        # Handle global seed if present
        try:
            if hasattr(config, "global_seed") and config.global_seed is not None:
                set_global_seed(config.global_seed)
                logger.debug(f"Set global seed to {config.global_seed}")
        except Exception as e:
            logger.debug(f"Could not set global seed: {e}")
    
        key = normalize_controller_name(ctrl_name)
    
        # Get controllers from config
        controllers_map = _as_dict(getattr(config, "controllers", {}))
    
        # Legacy classical_smc aliasing
        if key not in controllers_map and key == "classical_smc" and "classic_smc" in controllers_map:
            key = "classic_smc"
    
        if key not in controllers_map:
            available = "none configured" if len(controllers_map) == 0 else ", ".join(sorted(controllers_map.keys()))
&gt;           raise FactoryConfigurationError(
                f"Controller '{ctrl_name}' not found in config.controllers. Available: {available}"
            )
E           src.controllers.factory.FactoryConfigurationError: Controller 'hybrid_adaptive_sta_smc' not found in config.controllers. Available: SMC

src\controllers\factory.py:607: FactoryConfigurationError</error></testcase><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_dead_zone_freezes_int_and_gains" time="0.002" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_anti_windup_rolls_back_integral" time="0.001" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_adaptation_rate_limit_and_clip" time="0.272" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_saturation_respected" time="0.003" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_u_eq_safety_zero_on_bad_condition" time="0.001" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_reproducible_trajectories" time="0.002" /><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_robustness_sweep[0.0005-0.15--0.1]" time="0.003"><failure message="AssertionError: assert np.False_&#10; +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.15, 0.1 ]) &lt; 0.05)&#10; +    where &lt;function all at 0x000002907A299370&gt; = np.all&#10; +    and   array([0.  , 0.15, 0.1 ]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.15, -0.1 ]))&#10; +      where &lt;ufunc 'absolute'&gt; = np.abs">make_hybrid = &lt;function make_hybrid.&lt;locals&gt;._make at 0x000002900E19B240&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
dt = 0.0005, th1 = 0.15, th2 = -0.1

    @pytest.mark.parametrize(
        "dt,th1,th2",
        [
            (0.0005, 0.15, -0.10),
            (0.0010, 0.20, -0.15),
            (0.0015, 0.12, -0.08),
        ],
    )
    def test_robustness_sweep(make_hybrid, full_dynamics, dt, th1, th2):
        """Controller should stabilise a range of initial perturbations without NaNs or saturation."""
        from src.core.simulation_runner import run_simulation
        ctrl = make_hybrid(dt=dt)
        if hasattr(ctrl, "set_dynamics"):
            ctrl.set_dynamics(full_dynamics)
        x0 = np.array([0.0, th1, th2, 0.0, 0.0, 0.0], dtype=float)
        _, X, U = run_simulation(controller=ctrl, dynamics_model=full_dynamics, sim_time=5.0, dt=dt, initial_state=x0)
        # Ensure no infinities or NaNs in the state trajectory
        assert np.all(np.isfinite(X))
        # Control should respect the actuator limit
        assert np.max(np.abs(U)) &lt;= ctrl.max_force + 1e-9
        # Final angles should be close to upright
&gt;       assert np.all(np.abs(X[-1, :3]) &lt; 0.05)
E       AssertionError: assert np.False_
E        +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.15, 0.1 ]) &lt; 0.05)
E        +    where &lt;function all at 0x000002907A299370&gt; = np.all
E        +    and   array([0.  , 0.15, 0.1 ]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.15, -0.1 ]))
E        +      where &lt;ufunc 'absolute'&gt; = np.abs

tests\test_controllers\test_hybrid_extra.py:198: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_robustness_sweep[0.001-0.2--0.15]" time="0.002"><failure message="AssertionError: assert np.False_&#10; +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.2 , 0.15]) &lt; 0.05)&#10; +    where &lt;function all at 0x000002907A299370&gt; = np.all&#10; +    and   array([0.  , 0.2 , 0.15]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.2 , -0.15]))&#10; +      where &lt;ufunc 'absolute'&gt; = np.abs">make_hybrid = &lt;function make_hybrid.&lt;locals&gt;._make at 0x000002900E199EE0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
dt = 0.001, th1 = 0.2, th2 = -0.15

    @pytest.mark.parametrize(
        "dt,th1,th2",
        [
            (0.0005, 0.15, -0.10),
            (0.0010, 0.20, -0.15),
            (0.0015, 0.12, -0.08),
        ],
    )
    def test_robustness_sweep(make_hybrid, full_dynamics, dt, th1, th2):
        """Controller should stabilise a range of initial perturbations without NaNs or saturation."""
        from src.core.simulation_runner import run_simulation
        ctrl = make_hybrid(dt=dt)
        if hasattr(ctrl, "set_dynamics"):
            ctrl.set_dynamics(full_dynamics)
        x0 = np.array([0.0, th1, th2, 0.0, 0.0, 0.0], dtype=float)
        _, X, U = run_simulation(controller=ctrl, dynamics_model=full_dynamics, sim_time=5.0, dt=dt, initial_state=x0)
        # Ensure no infinities or NaNs in the state trajectory
        assert np.all(np.isfinite(X))
        # Control should respect the actuator limit
        assert np.max(np.abs(U)) &lt;= ctrl.max_force + 1e-9
        # Final angles should be close to upright
&gt;       assert np.all(np.abs(X[-1, :3]) &lt; 0.05)
E       AssertionError: assert np.False_
E        +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.2 , 0.15]) &lt; 0.05)
E        +    where &lt;function all at 0x000002907A299370&gt; = np.all
E        +    and   array([0.  , 0.2 , 0.15]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.2 , -0.15]))
E        +      where &lt;ufunc 'absolute'&gt; = np.abs

tests\test_controllers\test_hybrid_extra.py:198: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_robustness_sweep[0.0015-0.12--0.08]" time="0.003"><failure message="AssertionError: assert np.False_&#10; +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.12, 0.08]) &lt; 0.05)&#10; +    where &lt;function all at 0x000002907A299370&gt; = np.all&#10; +    and   array([0.  , 0.12, 0.08]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.12, -0.08]))&#10; +      where &lt;ufunc 'absolute'&gt; = np.abs">make_hybrid = &lt;function make_hybrid.&lt;locals&gt;._make at 0x000002900E19B7E0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
dt = 0.0015, th1 = 0.12, th2 = -0.08

    @pytest.mark.parametrize(
        "dt,th1,th2",
        [
            (0.0005, 0.15, -0.10),
            (0.0010, 0.20, -0.15),
            (0.0015, 0.12, -0.08),
        ],
    )
    def test_robustness_sweep(make_hybrid, full_dynamics, dt, th1, th2):
        """Controller should stabilise a range of initial perturbations without NaNs or saturation."""
        from src.core.simulation_runner import run_simulation
        ctrl = make_hybrid(dt=dt)
        if hasattr(ctrl, "set_dynamics"):
            ctrl.set_dynamics(full_dynamics)
        x0 = np.array([0.0, th1, th2, 0.0, 0.0, 0.0], dtype=float)
        _, X, U = run_simulation(controller=ctrl, dynamics_model=full_dynamics, sim_time=5.0, dt=dt, initial_state=x0)
        # Ensure no infinities or NaNs in the state trajectory
        assert np.all(np.isfinite(X))
        # Control should respect the actuator limit
        assert np.max(np.abs(U)) &lt;= ctrl.max_force + 1e-9
        # Final angles should be close to upright
&gt;       assert np.all(np.abs(X[-1, :3]) &lt; 0.05)
E       AssertionError: assert np.False_
E        +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.12, 0.08]) &lt; 0.05)
E        +    where &lt;function all at 0x000002907A299370&gt; = np.all
E        +    and   array([0.  , 0.12, 0.08]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.12, -0.08]))
E        +      where &lt;ufunc 'absolute'&gt; = np.abs

tests\test_controllers\test_hybrid_extra.py:198: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_gain_growth_slows_in_second_half" time="1.414"><failure message="assert np.float64(-4.2613352380251477e-116) &lt;= (np.float64(-9.996470588235294e-06) + 1e-09)">make_hybrid = &lt;function make_hybrid.&lt;locals&gt;._make at 0x000002900E19BBA0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
initial_state = array([ 0.  ,  0.1 , -0.05,  0.  ,  0.  ,  0.  ])

    def test_gain_growth_slows_in_second_half(make_hybrid, full_dynamics, initial_state):
        """Adaptive gains should grow more slowly in the second half of a simulation."""
        from src.core.simulation_runner import run_simulation
        ctrl = make_hybrid()
        if hasattr(ctrl, "set_dynamics"):
            ctrl.set_dynamics(full_dynamics)
        # Run a moderately long simulation to gather a history
        _, X, _ = run_simulation(controller=ctrl, dynamics_model=full_dynamics, sim_time=10.0, dt=0.001, initial_state=initial_state)
        # Recompute control offline to collect gain histories
        state_vars, history = _init_sv_hist(ctrl)
        for state in X:
            _, state_vars, history = _compute(ctrl, state, state_vars, history)
        k1_hist = np.array(history.get("k1", []), dtype=float)
        k2_hist = np.array(history.get("k2", []), dtype=float)
        # Compute mean increment in the first and second halves
        n = len(k1_hist)
        if n &lt; 4:
            pytest.skip("Not enough samples to assess gain growth")
        mid = n // 2
        inc1_k1 = (k1_hist[mid] - k1_hist[0]) / max(1, mid)
        inc2_k1 = (k1_hist[-1] - k1_hist[mid]) / max(1, n - mid)
        inc1_k2 = (k2_hist[mid] - k2_hist[0]) / max(1, mid)
        inc2_k2 = (k2_hist[-1] - k2_hist[mid]) / max(1, n - mid)
&gt;       assert inc2_k1 &lt;= inc1_k1 + 1e-9
E       assert np.float64(-4.2613352380251477e-116) &lt;= (np.float64(-9.996470588235294e-06) + 1e-09)

tests\test_controllers\test_hybrid_extra.py:224: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_hybrid_extra" name="test_long_run_no_drift" time="0.003"><failure message="AssertionError: assert np.False_&#10; +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.1 , 0.05]) &lt; 0.02)&#10; +    where &lt;function all at 0x000002907A299370&gt; = np.all&#10; +    and   array([0.  , 0.1 , 0.05]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.1 , -0.05]))&#10; +      where &lt;ufunc 'absolute'&gt; = np.abs">make_hybrid = &lt;function make_hybrid.&lt;locals&gt;._make at 0x000002900E19A7A0&gt;
full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
initial_state = array([ 0.  ,  0.1 , -0.05,  0.  ,  0.  ,  0.  ])

    @pytest.mark.slow
    def test_long_run_no_drift(make_hybrid, full_dynamics, initial_state):
        """Over a long duration the controller should stabilise without drift."""
        from src.core.simulation_runner import run_simulation
        ctrl = make_hybrid()
        if hasattr(ctrl, "set_dynamics"):
            ctrl.set_dynamics(full_dynamics)
        _, X, U = run_simulation(controller=ctrl, dynamics_model=full_dynamics, sim_time=30.0, dt=0.001, initial_state=initial_state)
        # Actuator should respect its limit even over long horizons
        assert np.max(np.abs(U)) &lt;= ctrl.max_force + 1e-9
        # Final state should be close to the upright equilibrium
&gt;       assert np.all(np.abs(X[-1, :3]) &lt; 0.02)
E       AssertionError: assert np.False_
E        +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([0.  , 0.1 , 0.05]) &lt; 0.02)
E        +    where &lt;function all at 0x000002907A299370&gt; = np.all
E        +    and   array([0.  , 0.1 , 0.05]) = &lt;ufunc 'absolute'&gt;(array([ 0.  ,  0.1 , -0.05]))
E        +      where &lt;ufunc 'absolute'&gt; = np.abs

tests\test_controllers\test_hybrid_extra.py:239: AssertionError</failure></testcase><testcase classname="tests.test_controllers.test_mpc_consolidated" name="test_mpc_optional_dep_and_param_validation" time="0.003"><failure message="ValueError: Controller 'mpc_controller' is not a recognized type">name = 'mpc_controller', kwargs = {}, controller_name = 'mpc_controller'
normalized_kwargs = {'config': &lt;test_mpc_consolidated.test_mpc_optional_dep_and_param_validation.&lt;locals&gt;.CfgA object at 0x000002907F505010&gt;, 'gains': None}
gains = None

    def create_controller(name: str, /, **kwargs: Any) -&gt; Any:
        """
        Backwards-compatible convenience wrapper used by tests and the CLI.
        Delegates to build_controller() so mapping/validation stays centralized.
    
        Parameters
        ----------
        name : str
            Controller name (aliases allowed).
        **kwargs :
            Per-controller constructor args (e.g., gains, dt, max_force).
        """
        # Unknown *controller names* must still raise.
        # allow_unknown=True relaxes parameter filtering only.
    
        # Normalize controller name
        controller_name = normalize_controller_name(name)
    
        # Check registry first
        with CONTROLLER_REGISTRY_LOCK:
            if controller_name in CONTROLLER_REGISTRY:
                return build_controller(name, kwargs, allow_unknown=True)
    
        # For tests and direct usage, try to create directly without config.yaml
        # Apply deprecation mapping first
        normalized_kwargs = apply_deprecation_mapping(controller_name, kwargs, allow_unknown=True)
    
        # Handle direct controller construction for common cases
        if controller_name == "classical_smc" and ClassicalSMC is not None:
            # Extract required parameters
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            max_force = normalized_kwargs.get('max_force', 20.0)
            boundary_layer = normalized_kwargs.get('boundary_layer', 0.01)
    
            # Filter known parameters
            known_params = {
                'gains': gains,
                'max_force': max_force,
                'boundary_layer': boundary_layer,
                'dynamics_model': normalized_kwargs.get('dynamics_model'),
                'regularization': normalized_kwargs.get('regularization', 1e-10),
                'switch_method': normalized_kwargs.get('switch_method', 'tanh'),
            }
    
            # Remove None values
            filtered_params = {k: v for k, v in known_params.items() if v is not None}
    
            return ClassicalSMC(**filtered_params)
    
        elif controller_name == "sta_smc" and SuperTwistingSMC is not None:
            # Similar handling for SuperTwistingSMC
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            max_force = normalized_kwargs.get('max_force', 20.0)
            boundary_layer = normalized_kwargs.get('boundary_layer', 0.01)
            dt = normalized_kwargs.get('dt', 0.01)
    
            known_params = {
                'gains': gains,
                'max_force': max_force,
                'boundary_layer': boundary_layer,
                'dt': dt,
                'dynamics_model': normalized_kwargs.get('dynamics_model'),
                'damping_gain': normalized_kwargs.get('damping_gain', 0.0),
                'regularization': normalized_kwargs.get('regularization', 1e-10),
                'switch_method': normalized_kwargs.get('switch_method', 'tanh'),
            }
    
            # Handle optional anti_windup_gain
            if 'anti_windup_gain' in normalized_kwargs:
                known_params['anti_windup_gain'] = normalized_kwargs['anti_windup_gain']
    
            filtered_params = {k: v for k, v in known_params.items() if v is not None}
    
            return SuperTwistingSMC(**filtered_params)
    
        elif controller_name == "adaptive_smc" and AdaptiveSMC is not None:
            # Similar handling for AdaptiveSMC with required defaults
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            known_params = {
                'gains': gains,
                'dt': normalized_kwargs.get('dt', 0.01),
                'max_force': normalized_kwargs.get('max_force', 20.0),
                'leak_rate': normalized_kwargs.get('leak_rate', 0.1),
                'dead_zone': normalized_kwargs.get('dead_zone', 0.01),
                'adapt_rate_limit': normalized_kwargs.get('adapt_rate_limit', 100.0),
                'K_min': normalized_kwargs.get('K_min', 0.1),
                'K_max': normalized_kwargs.get('K_max', 100.0),
                'smooth_switch': normalized_kwargs.get('smooth_switch', True),
                'boundary_layer': normalized_kwargs.get('boundary_layer', 0.01),
                'K_init': normalized_kwargs.get('K_init', 10.0),
                'alpha': normalized_kwargs.get('alpha', 0.5),
            }
    
            # All parameters have defaults, so just pass them all
            return AdaptiveSMC(**known_params)
    
        # For unknown controller names or when direct construction fails,
        # fall back to full build_controller with config loading
        try:
            config = kwargs.pop('config', None)
            gains = kwargs.pop('gains', None)
    
&gt;           return build_controller(
                name,
                kwargs,
                config=config,
                gains=gains,
                allow_unknown=True
            )

src\controllers\factory.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\controllers\factory.py:511: in build_controller
    return _legacy_create_controller(name, cfg, config, gains, allow_unknown)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src\controllers\factory.py:689: in _legacy_create_controller
    return _build_mpc_controller(key, ctrl_cfg_dict, config, gains, shared_dt, shared_max_force, allow_unknown)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

key = 'mpc_controller'
ctrl_cfg_dict = {'horizon': 5, 'q_theta': 1.0, 'q_x': 1.0, 'r_u': 0.1}
config = &lt;test_mpc_consolidated.test_mpc_optional_dep_and_param_validation.&lt;locals&gt;.CfgA object at 0x000002907F505010&gt;
gains = None, shared_dt = 0.01, shared_max_force = 20.0, allow_unknown = True

    def _build_mpc_controller(key, ctrl_cfg_dict, config, gains, shared_dt, shared_max_force, allow_unknown):
        if MPCController is None:
&gt;           raise ImportError(
                "Controller 'mpc_controller' is unavailable (missing optional dependency)."
            )
E           ImportError: Controller 'mpc_controller' is unavailable (missing optional dependency).

src\controllers\factory.py:941: ImportError

During handling of the above exception, another exception occurred:

monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E171260&gt;

    def test_mpc_optional_dep_and_param_validation(monkeypatch):
        class Dyn:
            def __init__(self, physics): pass
        monkeypatch.setattr(factory, "DoubleInvertedPendulum", Dyn, raising=False)
    
        # a) optional dependency guard
        monkeypatch.setattr(factory, "MPCController", None, raising=False)
        class CfgA:
            class Sim: use_full_dynamics = False; dt = 0.01
            simulation = Sim(); physics = object()
            controllers = {"mpc_controller": {"horizon": 5, "q_x": 1.0, "q_theta": 1.0, "r_u": 0.1}}
            controller_defaults = {}
        with pytest.raises(ImportError) as e1:
&gt;           factory.create_controller("mpc_controller", config=CfgA(), gains=None)

tests\test_controllers\test_mpc_consolidated.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'mpc_controller', kwargs = {}, controller_name = 'mpc_controller'
normalized_kwargs = {'config': &lt;test_mpc_consolidated.test_mpc_optional_dep_and_param_validation.&lt;locals&gt;.CfgA object at 0x000002907F505010&gt;, 'gains': None}
gains = None

    def create_controller(name: str, /, **kwargs: Any) -&gt; Any:
        """
        Backwards-compatible convenience wrapper used by tests and the CLI.
        Delegates to build_controller() so mapping/validation stays centralized.
    
        Parameters
        ----------
        name : str
            Controller name (aliases allowed).
        **kwargs :
            Per-controller constructor args (e.g., gains, dt, max_force).
        """
        # Unknown *controller names* must still raise.
        # allow_unknown=True relaxes parameter filtering only.
    
        # Normalize controller name
        controller_name = normalize_controller_name(name)
    
        # Check registry first
        with CONTROLLER_REGISTRY_LOCK:
            if controller_name in CONTROLLER_REGISTRY:
                return build_controller(name, kwargs, allow_unknown=True)
    
        # For tests and direct usage, try to create directly without config.yaml
        # Apply deprecation mapping first
        normalized_kwargs = apply_deprecation_mapping(controller_name, kwargs, allow_unknown=True)
    
        # Handle direct controller construction for common cases
        if controller_name == "classical_smc" and ClassicalSMC is not None:
            # Extract required parameters
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            max_force = normalized_kwargs.get('max_force', 20.0)
            boundary_layer = normalized_kwargs.get('boundary_layer', 0.01)
    
            # Filter known parameters
            known_params = {
                'gains': gains,
                'max_force': max_force,
                'boundary_layer': boundary_layer,
                'dynamics_model': normalized_kwargs.get('dynamics_model'),
                'regularization': normalized_kwargs.get('regularization', 1e-10),
                'switch_method': normalized_kwargs.get('switch_method', 'tanh'),
            }
    
            # Remove None values
            filtered_params = {k: v for k, v in known_params.items() if v is not None}
    
            return ClassicalSMC(**filtered_params)
    
        elif controller_name == "sta_smc" and SuperTwistingSMC is not None:
            # Similar handling for SuperTwistingSMC
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            max_force = normalized_kwargs.get('max_force', 20.0)
            boundary_layer = normalized_kwargs.get('boundary_layer', 0.01)
            dt = normalized_kwargs.get('dt', 0.01)
    
            known_params = {
                'gains': gains,
                'max_force': max_force,
                'boundary_layer': boundary_layer,
                'dt': dt,
                'dynamics_model': normalized_kwargs.get('dynamics_model'),
                'damping_gain': normalized_kwargs.get('damping_gain', 0.0),
                'regularization': normalized_kwargs.get('regularization', 1e-10),
                'switch_method': normalized_kwargs.get('switch_method', 'tanh'),
            }
    
            # Handle optional anti_windup_gain
            if 'anti_windup_gain' in normalized_kwargs:
                known_params['anti_windup_gain'] = normalized_kwargs['anti_windup_gain']
    
            filtered_params = {k: v for k, v in known_params.items() if v is not None}
    
            return SuperTwistingSMC(**filtered_params)
    
        elif controller_name == "adaptive_smc" and AdaptiveSMC is not None:
            # Similar handling for AdaptiveSMC with required defaults
            gains = normalized_kwargs.get('gains')
            if gains is None:
                raise ValueError(f"Controller '{name}': gains parameter is required")
    
            known_params = {
                'gains': gains,
                'dt': normalized_kwargs.get('dt', 0.01),
                'max_force': normalized_kwargs.get('max_force', 20.0),
                'leak_rate': normalized_kwargs.get('leak_rate', 0.1),
                'dead_zone': normalized_kwargs.get('dead_zone', 0.01),
                'adapt_rate_limit': normalized_kwargs.get('adapt_rate_limit', 100.0),
                'K_min': normalized_kwargs.get('K_min', 0.1),
                'K_max': normalized_kwargs.get('K_max', 100.0),
                'smooth_switch': normalized_kwargs.get('smooth_switch', True),
                'boundary_layer': normalized_kwargs.get('boundary_layer', 0.01),
                'K_init': normalized_kwargs.get('K_init', 10.0),
                'alpha': normalized_kwargs.get('alpha', 0.5),
            }
    
            # All parameters have defaults, so just pass them all
            return AdaptiveSMC(**known_params)
    
        # For unknown controller names or when direct construction fails,
        # fall back to full build_controller with config loading
        try:
            config = kwargs.pop('config', None)
            gains = kwargs.pop('gains', None)
    
            return build_controller(
                name,
                kwargs,
                config=config,
                gains=gains,
                allow_unknown=True
            )
        except Exception:
            # If all else fails, raise error for unknown controller
&gt;           raise ValueError(f"Controller '{name}' is not a recognized type")
E           ValueError: Controller 'mpc_controller' is not a recognized type

src\controllers\factory.py:1171: ValueError</failure></testcase><testcase classname="tests.test_controllers.test_mpc_controller" name="test_mpc_controller_instantiation_and_control" time="0.001" /><testcase classname="tests.test_controllers.test_mpc_controller" name="test_simulation_helper_shapes" time="0.001" /><testcase classname="tests.test_controllers.test_smc_guardrails_consolidated" name="test_smc_guardrails_and_smokes" time="0.001"><failure message="ValueError: Controller 'classical_smc': gains parameter is required">monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E171480&gt;

    def test_smc_guardrails_and_smokes(monkeypatch):
        class Dyn:
            def __init__(self, physics): pass
    
        # a) classical: boundary_layer &lt;= 0 -&gt; factory-time error
        monkeypatch.setattr(factory, "DoubleInvertedPendulum", Dyn, raising=False)
        class FakeClassical:
            def __init__(self, **kwargs): pass
        monkeypatch.setattr(factory, "ClassicalSMC", FakeClassical, raising=False)
    
        class CfgBadBL:
            class Sim: use_full_dynamics = False; dt = 0.01
            simulation = Sim(); controllers = {"classical_smc": {"gains":[1,1,1], "boundary_layer": 0.0}}
            controller_defaults = {}
        with pytest.raises(factory.ConfigValueError):
&gt;           factory.create_controller("classical_smc", config=CfgBadBL(), gains=None)

tests\test_controllers\test_smc_guardrails_consolidated.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'classical_smc'
kwargs = {'config': &lt;test_smc_guardrails_consolidated.test_smc_guardrails_and_smokes.&lt;locals&gt;.CfgBadBL object at 0x000002907F5DAA50&gt;, 'gains': None}
controller_name = 'classical_smc'
normalized_kwargs = {'config': &lt;test_smc_guardrails_consolidated.test_smc_guardrails_and_smokes.&lt;locals&gt;.CfgBadBL object at 0x000002907F5DAA50&gt;, 'gains': None}
gains = None

    def create_controller(name: str, /, **kwargs: Any) -&gt; Any:
        """
        Backwards-compatible convenience wrapper used by tests and the CLI.
        Delegates to build_controller() so mapping/validation stays centralized.
    
        Parameters
        ----------
        name : str
            Controller name (aliases allowed).
        **kwargs :
            Per-controller constructor args (e.g., gains, dt, max_force).
        """
        # Unknown *controller names* must still raise.
        # allow_unknown=True relaxes parameter filtering only.
    
        # Normalize controller name
        controller_name = normalize_controller_name(name)
    
        # Check registry first
        with CONTROLLER_REGISTRY_LOCK:
            if controller_name in CONTROLLER_REGISTRY:
                return build_controller(name, kwargs, allow_unknown=True)
    
        # For tests and direct usage, try to create directly without config.yaml
        # Apply deprecation mapping first
        normalized_kwargs = apply_deprecation_mapping(controller_name, kwargs, allow_unknown=True)
    
        # Handle direct controller construction for common cases
        if controller_name == "classical_smc" and ClassicalSMC is not None:
            # Extract required parameters
            gains = normalized_kwargs.get('gains')
            if gains is None:
&gt;               raise ValueError(f"Controller '{name}': gains parameter is required")
E               ValueError: Controller 'classical_smc': gains parameter is required

src\controllers\factory.py:1083: ValueError</failure></testcase><testcase classname="tests.test_controllers.test_sta_smc" name="test_finite_time_convergence" time="0.001"><error message="failed on setup with &quot;pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig&#10;cart_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;gravity&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;cart_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint1_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint2_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&quot;">physics_params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    @pytest.fixture
    def dynamics(physics_params):
&gt;       return DoubleInvertedPendulum(physics_params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_controllers\test_sta_smc.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.core.dynamics.DoubleInvertedPendulum object at 0x000002900E1B9050&gt;
params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def __init__(self, params: Any):
        """
        Initialize the simplified double inverted pendulum dynamics model.
    
        Parameters
        ----------
        params : Any
            A physics configuration specifying the system constants.  This
            must either be an instance of :class:`src.config.PhysicsConfig`
            or a mapping with the same keys.  Passing a mapping will
            attempt to construct a :class:`PhysicsConfig` to ensure the
            values are validated.  Any failure to import or construct
            the configuration will propagate an exception.
        """
        # PhysicsConfig is imported at the module level.  Avoid re‑importing
        # it here to prevent circular import issues when running tests
        # under alternative import paths.  The top‑level import ensures
        # PhysicsConfig is available.
    
        if params is None:
            raise ValueError("Physics parameters must not be None")
    
        # Determine whether the input is already a validated PhysicsConfig.
        if isinstance(params, PhysicsConfig):
            phys_cfg = params
        else:
            # Extract a plain dictionary from the input.  Accept Pydantic‑like
            # objects that implement model_dump(), plain dicts, or objects
            # that can be converted via dict().  Raise if conversion is
            # impossible so that invalid inputs are not silently accepted.
            if hasattr(params, "model_dump"):
                param_dict = params.model_dump()
            elif isinstance(params, dict):
                param_dict = params
            else:
                try:
                    param_dict = dict(params)
                except Exception:
                    raise TypeError(
                        "Physics parameters must be a PhysicsConfig or dict‑like mapping"
                    )
            # Construct a PhysicsConfig from the dictionary.  This will
            # perform full Pydantic validation and raise on invalid or
            # missing fields.
&gt;           phys_cfg = PhysicsConfig(**param_dict)  # type: ignore[arg-type]
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig
E           cart_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           gravity
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           cart_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint1_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint2_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

src\core\dynamics.py:449: ValidationError</error></testcase><testcase classname="tests.test_controllers.test_sta_smc" name="test_initialize_and_compute_control" time="0.001"><error message="failed on setup with &quot;pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig&#10;cart_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;gravity&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;cart_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint1_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint2_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&quot;">physics_params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    @pytest.fixture
    def dynamics(physics_params):
&gt;       return DoubleInvertedPendulum(physics_params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_controllers\test_sta_smc.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.core.dynamics.DoubleInvertedPendulum object at 0x000002900E2189B0&gt;
params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def __init__(self, params: Any):
        """
        Initialize the simplified double inverted pendulum dynamics model.
    
        Parameters
        ----------
        params : Any
            A physics configuration specifying the system constants.  This
            must either be an instance of :class:`src.config.PhysicsConfig`
            or a mapping with the same keys.  Passing a mapping will
            attempt to construct a :class:`PhysicsConfig` to ensure the
            values are validated.  Any failure to import or construct
            the configuration will propagate an exception.
        """
        # PhysicsConfig is imported at the module level.  Avoid re‑importing
        # it here to prevent circular import issues when running tests
        # under alternative import paths.  The top‑level import ensures
        # PhysicsConfig is available.
    
        if params is None:
            raise ValueError("Physics parameters must not be None")
    
        # Determine whether the input is already a validated PhysicsConfig.
        if isinstance(params, PhysicsConfig):
            phys_cfg = params
        else:
            # Extract a plain dictionary from the input.  Accept Pydantic‑like
            # objects that implement model_dump(), plain dicts, or objects
            # that can be converted via dict().  Raise if conversion is
            # impossible so that invalid inputs are not silently accepted.
            if hasattr(params, "model_dump"):
                param_dict = params.model_dump()
            elif isinstance(params, dict):
                param_dict = params
            else:
                try:
                    param_dict = dict(params)
                except Exception:
                    raise TypeError(
                        "Physics parameters must be a PhysicsConfig or dict‑like mapping"
                    )
            # Construct a PhysicsConfig from the dictionary.  This will
            # perform full Pydantic validation and raise on invalid or
            # missing fields.
&gt;           phys_cfg = PhysicsConfig(**param_dict)  # type: ignore[arg-type]
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig
E           cart_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           gravity
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           cart_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint1_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint2_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

src\core\dynamics.py:449: ValidationError</error></testcase><testcase classname="tests.test_controllers.test_sta_smc" name="test_sta_smc_equivalent_control_singular" time="0.001" /><testcase classname="tests.test_controllers.test_sta_smc" name="test_equivalent_control_handles_singularity" time="0.001" /><testcase classname="tests.test_controllers.test_sta_smc" name="test_equivalent_control_clamps_large_value" time="0.002" /><testcase classname="tests.test_controllers.test_swing_up_smc" name="test_initial_mode_and_control" time="0.001" /><testcase classname="tests.test_controllers.test_swing_up_smc" name="test_switch_to_stabilize" time="0.001" /><testcase classname="tests.test_controllers.test_swing_up_smc" name="test_hysteresis_transition" time="0.001" /><testcase classname="tests.test_core.test_config" name="test_config_loads_and_maps_controllers" time="0.027" /><testcase classname="tests.test_core.test_config" name="test_physics_config_rejects_zero_mass" time="0.032" /><testcase classname="tests.test_core.test_config" name="test_physics_config_rejects_negative_inertia" time="0.029" /><testcase classname="tests.test_core.test_config" name="test_physics_config_rejects_invalid_com" time="0.039" /><testcase classname="tests.test_core.test_config" name="test_physics_config_rejects_nonpositive_com" time="0.025" /><testcase classname="tests.test_core.test_config" name="test_controller_config_forbids_extra_rate_weight_unit" time="0.001" /><testcase classname="tests.test_core.test_config" name="test_load_config_rejects_rate_weight_in_yaml" time="0.012" /><testcase classname="tests.test_core.test_determinism" name="test_cli_stdout_is_deterministic" time="1.885"><failure message="AssertionError: CLI failed (returncode=1).&#10;  STDOUT:&#10;  &#10;  STDERR:&#10;  ERROR:root:Application failed with a critical error: No module named 'pyswarms'&#10;  Traceback (most recent call last):&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\app.py&quot;, line 700, in main&#10;      return _run_pso(run_args)&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\app.py&quot;, line 376, in _run_pso&#10;      result = tuner.optimise()&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\src\optimizer\pso_optimizer.py&quot;, line 641, in optimise&#10;      from pyswarms.single import GlobalBestPSO&#10;  ModuleNotFoundError: No module named 'pyswarms'&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['C:\\Users\\sadeg\\AppData\\Local\\Programs\\Python\\Python313\\python.exe', 'D:\\Projects\\mai... 641, in optimise\n    from pyswarms.single import GlobalBestPSO\nModuleNotFoundError: No module named \'pyswarms\'\n').returncode">tmp_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_cli_stdout_is_determinist0')

    @pytest.mark.slow
    def test_cli_stdout_is_deterministic(tmp_path: Path):
        """Test that running PSO optimization twice produces identical results."""
        cfg = _create_fast_pso_config(tmp_path)
        # Run twice with the same seed via direct invocation
&gt;       out1 = _run_cli(cfg, seed=42)
               ^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_determinism.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

config = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_cli_stdout_is_determinist0/config.yaml')
seed = 42

    def _run_cli(config: Path, seed: int = 42) -&gt; str:
        """
        Run the CLI directly and return captured stdout as text.
        The seeding logic is handled inside app.py; this helper
        simply forwards the seed argument to the CLI entrypoint.
        """
        env = os.environ.copy()
        env["PYTHONUNBUFFERED"] = "1"
        app_path = _find_app_py()
        cmd = [
            sys.executable,
            str(app_path),
            "--run-pso",
            "--controller", "classical_smc",
            "--config", str(config),
            "--seed", str(seed),
        ]
        proc = subprocess.run(
            cmd,
            cwd=app_path.parent,
            capture_output=True,
            text=True,
            check=False,
            timeout=30,
            env=env,
        )
&gt;       assert proc.returncode == 0, (
            f"CLI failed (returncode={proc.returncode}).\n"
            f"STDOUT:\n{proc.stdout}\n"
            f"STDERR:\n{proc.stderr}"
        )
E       AssertionError: CLI failed (returncode=1).
E         STDOUT:
E         
E         STDERR:
E         ERROR:root:Application failed with a critical error: No module named 'pyswarms'
E         Traceback (most recent call last):
E           File "D:\Projects\main\DIP_SMC_PSO\app.py", line 700, in main
E             return _run_pso(run_args)
E           File "D:\Projects\main\DIP_SMC_PSO\app.py", line 376, in _run_pso
E             result = tuner.optimise()
E           File "D:\Projects\main\DIP_SMC_PSO\src\optimizer\pso_optimizer.py", line 641, in optimise
E             from pyswarms.single import GlobalBestPSO
E         ModuleNotFoundError: No module named 'pyswarms'
E         
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['C:\\Users\\sadeg\\AppData\\Local\\Programs\\Python\\Python313\\python.exe', 'D:\\Projects\\mai... 641, in optimise\n    from pyswarms.single import GlobalBestPSO\nModuleNotFoundError: No module named \'pyswarms\'\n').returncode

tests\test_core\test_determinism.py:109: AssertionError</failure></testcase><testcase classname="tests.test_core.test_dynamics" name="test_full_inertia_matrix_shape_and_symmetry" time="0.025" /><testcase classname="tests.test_core.test_dynamics" name="test_full_dynamics_computation" time="0.003" /><testcase classname="tests.test_core.test_dynamics" name="test_passivity_verification" time="0.003"><failure message="AssertionError: Passivity check failed: The model's energy increased without input.&#10;assert np.float64(0.015982053969444014) &lt;= (np.float64(0.015629310004639657) + 1e-06)">full_dynamics_model = &lt;src.core.dynamics_full.FullDIPDynamics object at 0x000002907F505010&gt;

    def test_passivity_verification(full_dynamics_model):
        """
        Verifies that the system's energy does not increase without external power input
        when friction (dissipation) is removed. This test is flawed in the original code,
        as FullDIPDynamics does not have a 'verify_passivity' method. We will test energy
        conservation instead.
        """
        # Create a frictionless version of the model for a pure energy conservation test
        params_dict = full_dynamics_model.p_model.model_dump()
        params_dict['cart_friction'] = 0.0
        params_dict['joint1_friction'] = 0.0
        params_dict['joint2_friction'] = 0.0
        model_no_friction = FullDIPDynamics(PhysicsConfig(**params_dict))
    
        state = np.array([0.0, 0.1, 0.05, 0.1, 0.2, 0.3])
        initial_energy = model_no_friction.total_energy(state)
    
        # Take one step with zero input force
        next_state = model_no_friction.step(state, u=0.0, dt=0.01)
        final_energy = model_no_friction.total_energy(next_state)
    
        # Energy should not increase (within a small tolerance for numerical error)
        # Allow a small tolerance due to numerical integration error.  A tolerance of
        # 1e-6 is more realistic for the RK4 integration used in the model.
&gt;       assert final_energy &lt;= initial_energy + 1e-6, (
            "Passivity check failed: The model's energy increased without input."
        )
E       AssertionError: Passivity check failed: The model's energy increased without input.
E       assert np.float64(0.015982053969444014) &lt;= (np.float64(0.015629310004639657) + 1e-06)

tests\test_core\test_dynamics.py:74: AssertionError</failure></testcase><testcase classname="tests.test_core.test_dynamics" name="test_singularity_check" time="0.002" /><testcase classname="tests.test_core.test_dynamics" name="test_step_returns_nan_on_singular_params" time="0.002" /><testcase classname="tests.test_core.test_dynamics" name="test_pso_fitness_penalises_nan" time="0.003" /><testcase classname="tests.test_core.test_dynamics" name="test_simplified_vs_full_model_error" time="0.002" /><testcase classname="tests.test_core.test_dynamics" name="test_rhs_returns_nan_for_ill_conditioned_matrix" time="0.002"><failure message="AssertionError: Expected NaNs for ill-conditioned inertia matrix&#10;assert np.False_&#10; +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([False, False, False, False, False, False]))&#10; +    where &lt;function all at 0x000002907A299370&gt; = np.all&#10; +    and   array([False, False, False, False, False, False]) = &lt;ufunc 'isnan'&gt;(array([ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  5.37795499e-01,\n       -2.16221406e+00,  5.99366737e-06]))&#10; +      where &lt;ufunc 'isnan'&gt; = np.isnan">def test_rhs_returns_nan_for_ill_conditioned_matrix():
        # Tiny m2/I2 -&gt; near-singular inertia in certain poses
        p = DIPParams(
            cart_mass=1.0,
            pendulum1_mass=1.0,
            pendulum2_mass=1e-9,
            pendulum1_length=1.0,
            pendulum2_length=1.0,
            pendulum1_com=0.5,
            pendulum2_com=0.5,
            pendulum1_inertia=0.1,
            pendulum2_inertia=1e-12,
            gravity=9.81,
            cart_friction=0.1,
            joint1_friction=0.01,
            joint2_friction=0.01,
        )
        state = np.array([0.0, 0.1, -0.1, 0.0, 0.0, 0.0], dtype=np.float64)
        out = rhs_numba(state, 0.0, p)
&gt;       assert np.all(np.isnan(out)), "Expected NaNs for ill-conditioned inertia matrix"
E       AssertionError: Expected NaNs for ill-conditioned inertia matrix
E       assert np.False_
E        +  where np.False_ = &lt;function all at 0x000002907A299370&gt;(array([False, False, False, False, False, False]))
E        +    where &lt;function all at 0x000002907A299370&gt; = np.all
E        +    and   array([False, False, False, False, False, False]) = &lt;ufunc 'isnan'&gt;(array([ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  5.37795499e-01,\n       -2.16221406e+00,  5.99366737e-06]))
E        +      where &lt;ufunc 'isnan'&gt; = np.isnan

tests\test_core\test_dynamics.py:299: AssertionError</failure></testcase><testcase classname="tests.test_core.test_dynamics" name="test_rhs_handles_singularity_gracefully" time="0.003"><failure message="AssertionError: rhs_numba should return NaN values when the inertia matrix is singular&#10;assert np.False_&#10; +  where np.False_ = &lt;function any at 0x000002907A2990B0&gt;(array([False, False, False, False, False, False]))&#10; +    where &lt;function any at 0x000002907A2990B0&gt; = np.any&#10; +    and   array([False, False, False, False, False, False]) = &lt;ufunc 'isnan'&gt;(array([0., 0., 0., 0., 0., 0.]))&#10; +      where &lt;ufunc 'isnan'&gt; = np.isnan">def test_rhs_handles_singularity_gracefully():
        """
        Ensures that when the inertia matrix H is singular, the rhs_numba function
        returns an array of NaN values to signal the numerical failure, preventing
        silent data corruption.
        """
        # Create a set of parameters known to cause a singular H matrix
        # (e.g., a massless second pendulum)
        singular_params = DIPParams(
            cart_mass=1.0,
            pendulum1_mass=1.0,
            pendulum2_mass=1e-12,  # Effectively massless
            pendulum1_length=1.0,
            pendulum2_length=1.0,
            pendulum1_com=0.5,
            pendulum2_com=0.5,
            pendulum1_inertia=0.1,
            pendulum2_inertia=1e-12, # Effectively no inertia
            gravity=9.81,
            cart_friction=0.1,
            joint1_friction=0.01,
            joint2_friction=0.01,
        )
    
        # A state vector where the singularity might be encountered
        state = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
        u = 0.0
    
        # Execute the function that could fail
        xdot = rhs_numba(state, u, singular_params)
    
        # Assert that the output contains NaN values (the correct behavior)
&gt;       assert np.any(np.isnan(xdot)), "rhs_numba should return NaN values when the inertia matrix is singular"
E       AssertionError: rhs_numba should return NaN values when the inertia matrix is singular
E       assert np.False_
E        +  where np.False_ = &lt;function any at 0x000002907A2990B0&gt;(array([False, False, False, False, False, False]))
E        +    where &lt;function any at 0x000002907A2990B0&gt; = np.any
E        +    and   array([False, False, False, False, False, False]) = &lt;ufunc 'isnan'&gt;(array([0., 0., 0., 0., 0., 0.]))
E        +      where &lt;ufunc 'isnan'&gt; = np.isnan

tests\test_core\test_dynamics.py:342: AssertionError</failure></testcase><testcase classname="tests.test_core.test_dynamics" name="test_pulse_clamped_to_sim_end" time="0.001" /><testcase classname="tests.test_core.test_dynamics_extra" name="test_inertia_shape_and_symmetry[state0]" time="0.001"><failure message="AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'">full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
state = array([0.        , 0.52359878, 0.39269908, 0.        , 0.        ,
       0.        ])

    @pytest.mark.parametrize(
        "state",
        [
            np.array([0.0, np.pi / 6.0, np.pi / 8.0, 0.0, 0.0, 0.0], dtype=float),
            np.array([0.1, np.pi / 4.0, np.pi / 3.0, 0.0, 0.0, 0.0], dtype=float),
        ],
    )
    def test_inertia_shape_and_symmetry(full_dynamics, state):
        """The inertia matrix must be 3×3 and symmetric for all finite states."""
&gt;       H, C, G = full_dynamics._compute_physics_matrices(state)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'

tests\test_core\test_dynamics_extra.py:23: AttributeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_extra" name="test_inertia_shape_and_symmetry[state1]" time="0.002"><failure message="AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'">full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;
state = array([0.1       , 0.78539816, 1.04719755, 0.        , 0.        ,
       0.        ])

    @pytest.mark.parametrize(
        "state",
        [
            np.array([0.0, np.pi / 6.0, np.pi / 8.0, 0.0, 0.0, 0.0], dtype=float),
            np.array([0.1, np.pi / 4.0, np.pi / 3.0, 0.0, 0.0, 0.0], dtype=float),
        ],
    )
    def test_inertia_shape_and_symmetry(full_dynamics, state):
        """The inertia matrix must be 3×3 and symmetric for all finite states."""
&gt;       H, C, G = full_dynamics._compute_physics_matrices(state)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'

tests\test_core\test_dynamics_extra.py:23: AttributeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_extra" name="test_passivity_energy_conservation_short_step" time="0.001"><failure message="AttributeError: 'Physics' object has no attribute 'model_copy'">physics_cfg = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def test_passivity_energy_conservation_short_step(physics_cfg):
        """In the absence of friction the total energy should not increase under zero input."""
        from src.core.dynamics_full import FullDIPDynamics
        # Create a copy of the physics config with zero frictions
&gt;       p = physics_cfg.model_copy(update=dict(
            ^^^^^^^^^^^^^^^^^^^^^^
            cart_friction=0.0,
            joint1_friction=0.0,
            joint2_friction=0.0,
        ))
E       AttributeError: 'Physics' object has no attribute 'model_copy'

tests\test_core\test_dynamics_extra.py:35: AttributeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_extra" name="test_singularity_and_regularization" time="0.001"><failure message="AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'">full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;

    def test_singularity_and_regularization(full_dynamics):
        """The inertia matrix eigenvalues should be finite even near singular configurations."""
        # A challenging configuration numerically (second pendulum inverted)
        x = np.array([0.0, 0.0, np.pi, 0.0, 0.0, 0.0], dtype=float)
&gt;       H, C, G = full_dynamics._compute_physics_matrices(x)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'

tests\test_core\test_dynamics_extra.py:53: AttributeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_extra" name="test_simplified_vs_full_zero_input_close" time="0.001"><failure message="ImportError: cannot import name 'DoubleInvertedPendulum' from 'src.core.dynamics' (unknown location)">physics_cfg = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def test_simplified_vs_full_zero_input_close(physics_cfg):
        """Under zero input the simplified and full models should remain close for a short horizon."""
&gt;       from src.core.dynamics import DoubleInvertedPendulum
E       ImportError: cannot import name 'DoubleInvertedPendulum' from 'src.core.dynamics' (unknown location)

tests\test_core\test_dynamics_extra.py:60: ImportError</failure></testcase><testcase classname="tests.test_core.test_dynamics_extra" name="test_numba_cache_regression" time="0.001"><failure message="AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'">full_dynamics = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.DIP object at 0x000002907FAC7890&gt;

    def test_numba_cache_regression(full_dynamics):
        """Repeated calls should not raise errors due to numba caching."""
        x = np.array([0.0, 0.2, -0.1, 0.0, 0.0, 0.0], dtype=float)
        # Call multiple times to exercise cached dispatch paths
        for _ in range(3):
&gt;           H, C, G = full_dynamics._compute_physics_matrices(x)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'DIP' object has no attribute '_compute_physics_matrices'

tests\test_core\test_dynamics_extra.py:84: AttributeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_full_instability" name="test_full_dynamics_raises_on_nan" time="0.002" /><testcase classname="tests.test_core.test_dynamics_full_integration.TestToggle" name="test_full_vs_lowrank_path" time="0.004"><failure message="RuntimeError: Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py">def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
&gt;           return getattr(mod, "step")
                   ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.core.dynamics_full' has no attribute 'step'

src\core\simulation_runner.py:52: AttributeError

During handling of the above exception, another exception occurred:

self = &lt;test_dynamics_full_integration.TestToggle object at 0x000002907EFA4550&gt;

    def test_full_vs_lowrank_path(self):
        """
        When ``config.simulation.use_full_dynamics`` is False the router should
        call ``src.core.dynamics_lowrank.step``.  When the flag is True it
        should call ``src.core.dynamics_full.step``.  Monkeypatch the
        respective ``step`` functions to return a sentinel value and assert
        that the correct path is taken.
        """
        # --- Low‑rank path ---
        config.simulation.use_full_dynamics = False
    
        # Patch low‑rank step to make the path observable
        import src.core.dynamics_lowrank as lowrank  # type: ignore
    
        def low_stub(x, u, dt):  # pragma: no cover - test hook
            return ("lowrank", x, u, dt)
    
        orig_low = lowrank.step
        lowrank.step = low_stub  # type: ignore[assignment]
        try:
            out = runner.step(1, 2, 0.1)
            assert out[0] == "lowrank"
        finally:
            lowrank.step = orig_low  # type: ignore[assignment]
    
        # --- Full path ---
        config.simulation.use_full_dynamics = True
    
        # Ensure a real/stub dynamics_full module is importable
        import src.core.dynamics_full as fullmod  # type: ignore
    
        def full_stub(x, u, dt):  # pragma: no cover - test hook
            return ("full", x, u, dt)
    
        orig_full = fullmod.step
        fullmod.step = full_stub  # type: ignore[assignment]
        try:
&gt;           out = runner.step(3, 4, 0.2)
                  ^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_dynamics_full_integration.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\core\simulation_runner.py:101: in step
    return get_step_fn()(x, u, dt)
           ^^^^^^^^^^^^^
src\core\simulation_runner.py:81: in get_step_fn
    return _load_full_step() if use_full else _load_lowrank_step()
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
            return getattr(mod, "step")
        except Exception:
            # EXACT message required by tests:
&gt;           raise RuntimeError(
                "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"
            )
E           RuntimeError: Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py

src\core\simulation_runner.py:55: RuntimeError</failure></testcase><testcase classname="tests.test_core.test_dynamics_full_integration.TestToggle" name="test_missing_full_model_error_message" time="0.002" /><testcase classname="tests.test_core.test_dynamics_lowrank.TestSafety" name="test_nan_guard_raises" time="0.001" /><testcase classname="tests.test_core.test_dynamics_lowrank.TestSafety" name="test_energy_bound_guard_raises" time="0.002" /><testcase classname="tests.test_core.test_dynamics_lowrank.TestSafety" name="test_state_bounds_guard_raises" time="0.002" /><testcase classname="tests.test_core.test_factory" name="test_factory_importable" time="0.001" /><testcase classname="tests.test_core.test_factory" name="test_create_classical_smc_custom_gains" time="0.001" /><testcase classname="tests.test_core.test_factory" name="test_invalid_controller_name_raises" time="0.024" /><testcase classname="tests.test_core.test_interfaces" name="test_simulation_is_thread_safe" time="0.001"><failure message="pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig&#10;cart_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;gravity&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;cart_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint1_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint2_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing">physics_params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def test_simulation_is_thread_safe(physics_params):
        """
        Verify that running simulations in parallel threads does not cause
        race conditions or state corruption by ensuring results are deterministic.
        """
        num_threads = 10
        seed = 42
    
        # 1. Run once in the main thread to get the "golden" result.
&gt;       expected_final_state = run_deterministic_simulation(seed, physics_params)
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_interfaces.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\test_core\test_interfaces.py:22: in run_deterministic_simulation
    dynamics_model = DIPDynamics(params=physics_params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.core.dynamics.DoubleInvertedPendulum object at 0x000002900E21A120&gt;
params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def __init__(self, params: Any):
        """
        Initialize the simplified double inverted pendulum dynamics model.
    
        Parameters
        ----------
        params : Any
            A physics configuration specifying the system constants.  This
            must either be an instance of :class:`src.config.PhysicsConfig`
            or a mapping with the same keys.  Passing a mapping will
            attempt to construct a :class:`PhysicsConfig` to ensure the
            values are validated.  Any failure to import or construct
            the configuration will propagate an exception.
        """
        # PhysicsConfig is imported at the module level.  Avoid re‑importing
        # it here to prevent circular import issues when running tests
        # under alternative import paths.  The top‑level import ensures
        # PhysicsConfig is available.
    
        if params is None:
            raise ValueError("Physics parameters must not be None")
    
        # Determine whether the input is already a validated PhysicsConfig.
        if isinstance(params, PhysicsConfig):
            phys_cfg = params
        else:
            # Extract a plain dictionary from the input.  Accept Pydantic‑like
            # objects that implement model_dump(), plain dicts, or objects
            # that can be converted via dict().  Raise if conversion is
            # impossible so that invalid inputs are not silently accepted.
            if hasattr(params, "model_dump"):
                param_dict = params.model_dump()
            elif isinstance(params, dict):
                param_dict = params
            else:
                try:
                    param_dict = dict(params)
                except Exception:
                    raise TypeError(
                        "Physics parameters must be a PhysicsConfig or dict‑like mapping"
                    )
            # Construct a PhysicsConfig from the dictionary.  This will
            # perform full Pydantic validation and raise on invalid or
            # missing fields.
&gt;           phys_cfg = PhysicsConfig(**param_dict)  # type: ignore[arg-type]
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig
E           cart_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           gravity
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           cart_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint1_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint2_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

src\core\dynamics.py:449: ValidationError</failure></testcase><testcase classname="tests.test_core.test_latency_and_logging" name="test_latency_monitor_fallback_engaged" time="0.004" /><testcase classname="tests.test_core.test_latency_and_logging" name="test_provenance_logging_attaches_metadata" time="0.061"><failure message="AssertionError: No log record captured for test message&#10;assert []">caplog = &lt;_pytest.logging.LogCaptureFixture object at 0x000002900E3BCB00&gt;

    def test_provenance_logging_attaches_metadata(caplog) -&gt; None:
        """The provenance logging setup should inject commit, config hash and seed."""
        # Ensure a clean logging environment.  Remove existing handlers
        logger = logging.getLogger()
        for h in list(logger.handlers):
            logger.removeHandler(h)
        # Configure logging with a dummy config and known seed
        config = {"foo": 1}
        seed_val = 123
        configure_provenance_logging(config, seed_val, level=logging.INFO)
        # Capture logging output
        with caplog.at_level(logging.INFO):
            logging.info("test message")
        # The first log record corresponds to the call to logging.info("test message")
        # There may be an earlier record from the configure_provenance_logging
        # startup message; filter records accordingly
        records = [r for r in caplog.records if r.getMessage() == "test message"]
&gt;       assert records, "No log record captured for test message"
E       AssertionError: No log record captured for test message
E       assert []

tests\test_core\test_latency_and_logging.py:112: AssertionError</failure></testcase><testcase classname="tests.test_core.test_lyapunov" name="test_lyapunov_decrease_sta" time="0.001"><error message="failed on setup with &quot;pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig&#10;cart_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_mass&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_length&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_com&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum1_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;pendulum2_inertia&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;gravity&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;cart_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint1_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&#10;joint2_friction&#10;  Field required [type=missing, input_value={}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing&quot;">physics_params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    @pytest.fixture
    def dynamics(physics_params):
        """
        Fixture for DIP dynamics model.
        This is consistent with other tests, using physics_params from conftest.py.
        """
&gt;       return DoubleInvertedPendulum(physics_params)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_lyapunov.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;src.core.dynamics.DoubleInvertedPendulum object at 0x000002900E2D6A50&gt;
params = &lt;test_streamlit_app.install_fake_modules.&lt;locals&gt;.Cfg.Physics object at 0x000002907F505160&gt;

    def __init__(self, params: Any):
        """
        Initialize the simplified double inverted pendulum dynamics model.
    
        Parameters
        ----------
        params : Any
            A physics configuration specifying the system constants.  This
            must either be an instance of :class:`src.config.PhysicsConfig`
            or a mapping with the same keys.  Passing a mapping will
            attempt to construct a :class:`PhysicsConfig` to ensure the
            values are validated.  Any failure to import or construct
            the configuration will propagate an exception.
        """
        # PhysicsConfig is imported at the module level.  Avoid re‑importing
        # it here to prevent circular import issues when running tests
        # under alternative import paths.  The top‑level import ensures
        # PhysicsConfig is available.
    
        if params is None:
            raise ValueError("Physics parameters must not be None")
    
        # Determine whether the input is already a validated PhysicsConfig.
        if isinstance(params, PhysicsConfig):
            phys_cfg = params
        else:
            # Extract a plain dictionary from the input.  Accept Pydantic‑like
            # objects that implement model_dump(), plain dicts, or objects
            # that can be converted via dict().  Raise if conversion is
            # impossible so that invalid inputs are not silently accepted.
            if hasattr(params, "model_dump"):
                param_dict = params.model_dump()
            elif isinstance(params, dict):
                param_dict = params
            else:
                try:
                    param_dict = dict(params)
                except Exception:
                    raise TypeError(
                        "Physics parameters must be a PhysicsConfig or dict‑like mapping"
                    )
            # Construct a PhysicsConfig from the dictionary.  This will
            # perform full Pydantic validation and raise on invalid or
            # missing fields.
&gt;           phys_cfg = PhysicsConfig(**param_dict)  # type: ignore[arg-type]
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           pydantic_core._pydantic_core.ValidationError: 13 validation errors for PhysicsConfig
E           cart_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_mass
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_length
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_com
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum1_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           pendulum2_inertia
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           gravity
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           cart_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint1_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing
E           joint2_friction
E             Field required [type=missing, input_value={}, input_type=dict]
E               For further information visit https://errors.pydantic.dev/2.11/v/missing

src\core\dynamics.py:449: ValidationError</error></testcase><testcase classname="tests.test_core.test_simulation" name="test_run_simulation_shapes" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_halts_on_nan" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_halts_on_exception" time="0.002" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_duration_accuracy[0.95-0.1]" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_duration_accuracy[1.04-0.1]" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_duration_accuracy[0.3-0.1]" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_duration_accuracy[1.0-0.3]" time="0.001" /><testcase classname="tests.test_core.test_simulation" name="test_simulation_duration_accuracy[0.1-0.01]" time="0.002" /><testcase classname="tests.test_core.test_stateful_simulation" name="test_stateful_controller_persists_state_and_history_is_exposed" time="0.005" /><testcase classname="tests.test_core.test_vector_sim_guards" name="test_simulate_bounds_guard_raises" time="0.001"><failure message="AssertionError: Regex pattern did not match.&#10; Regex: 'State bounds violated at t=&lt;t&gt;'&#10; Input: &quot;Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py&quot;">def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
&gt;           return getattr(mod, "step")
                   ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.core.dynamics_full' has no attribute 'step'

src\core\simulation_runner.py:52: AttributeError

During handling of the above exception, another exception occurred:

    def test_simulate_bounds_guard_raises():
        x0 = np.array([10.0, 0.0])
        u = np.array([0.0, 0.0])
        with pytest.raises(RuntimeError, match="State bounds violated at t=&lt;t&gt;"):
&gt;           _ = simulate(x0, u, dt=0.1, state_bounds=(np.array([-1.0, -1.0]), np.array([1.0, 1.0])))
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_vector_sim_guards.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\core\vector_sim.py:193: in simulate
    x_next = _step_fn(x_b, u_i, dt)
             ^^^^^^^^^^^^^^^^^^^^^^
src\core\simulation_runner.py:101: in step
    return get_step_fn()(x, u, dt)
           ^^^^^^^^^^^^^
src\core\simulation_runner.py:81: in get_step_fn
    return _load_full_step() if use_full else _load_lowrank_step()
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
            return getattr(mod, "step")
        except Exception:
            # EXACT message required by tests:
&gt;           raise RuntimeError(
                "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"
            )
E           RuntimeError: Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py

src\core\simulation_runner.py:55: RuntimeError

During handling of the above exception, another exception occurred:

    def test_simulate_bounds_guard_raises():
        x0 = np.array([10.0, 0.0])
        u = np.array([0.0, 0.0])
&gt;       with pytest.raises(RuntimeError, match="State bounds violated at t=&lt;t&gt;"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: Regex pattern did not match.
E        Regex: 'State bounds violated at t=&lt;t&gt;'
E        Input: "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"

tests\test_core\test_vector_sim_guards.py:22: AssertionError</failure></testcase><testcase classname="tests.test_core.test_vector_sim_guards" name="test_simulate_energy_guard_raises" time="0.001"><failure message="AssertionError: Regex pattern did not match.&#10; Regex: 'Energy check failed: total_energy=&lt;val&gt; exceeds &lt;max&gt;'&#10; Input: &quot;Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py&quot;">def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
&gt;           return getattr(mod, "step")
                   ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.core.dynamics_full' has no attribute 'step'

src\core\simulation_runner.py:52: AttributeError

During handling of the above exception, another exception occurred:

    def test_simulate_energy_guard_raises():
        x0 = np.array([100.0, 0.0])
        u = np.array([0.0, 0.0])
        with pytest.raises(RuntimeError, match="Energy check failed: total_energy=&lt;val&gt; exceeds &lt;max&gt;"):
&gt;           _ = simulate(x0, u, dt=0.1, energy_limits=10.0)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_vector_sim_guards.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\core\vector_sim.py:193: in simulate
    x_next = _step_fn(x_b, u_i, dt)
             ^^^^^^^^^^^^^^^^^^^^^^
src\core\simulation_runner.py:101: in step
    return get_step_fn()(x, u, dt)
           ^^^^^^^^^^^^^
src\core\simulation_runner.py:81: in get_step_fn
    return _load_full_step() if use_full else _load_lowrank_step()
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
            return getattr(mod, "step")
        except Exception:
            # EXACT message required by tests:
&gt;           raise RuntimeError(
                "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"
            )
E           RuntimeError: Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py

src\core\simulation_runner.py:55: RuntimeError

During handling of the above exception, another exception occurred:

    def test_simulate_energy_guard_raises():
        x0 = np.array([100.0, 0.0])
        u = np.array([0.0, 0.0])
&gt;       with pytest.raises(RuntimeError, match="Energy check failed: total_energy=&lt;val&gt; exceeds &lt;max&gt;"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: Regex pattern did not match.
E        Regex: 'Energy check failed: total_energy=&lt;val&gt; exceeds &lt;max&gt;'
E        Input: "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"

tests\test_core\test_vector_sim_guards.py:29: AssertionError</failure></testcase><testcase classname="tests.test_core.test_vector_sim_guards" name="test_simulate_nan_guard_raises" time="0.001"><failure message="AssertionError: Regex pattern did not match.&#10; Regex: 'NaN detected in state at step &lt;i&gt;'&#10; Input: &quot;Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py&quot;">def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
&gt;           return getattr(mod, "step")
                   ^^^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.core.dynamics_full' has no attribute 'step'

src\core\simulation_runner.py:52: AttributeError

During handling of the above exception, another exception occurred:

    def test_simulate_nan_guard_raises():
        # Build a trajectory that injects NaN at the second state (manually)
        # simulate checks guards on the provided state sequence, so create a control
        # sequence and then modify the state via a custom stop_fn to trigger NaN.
        x0 = np.array([0.0, 0.0])
        u = np.array([0.0, 0.0])
    
        # There is no hook to inject states into simulate, so emulate the guard directly
        # by calling _guard_no_nan via simulate's internals: easiest path is to provide
        # NaN initial state.
        with pytest.raises(RuntimeError, match="NaN detected in state at step &lt;i&gt;"):
&gt;           _ = simulate(np.array([np.nan, 0.0]), u, dt=0.1)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_core\test_vector_sim_guards.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
src\core\vector_sim.py:193: in simulate
    x_next = _step_fn(x_b, u_i, dt)
             ^^^^^^^^^^^^^^^^^^^^^^
src\core\simulation_runner.py:101: in step
    return get_step_fn()(x, u, dt)
           ^^^^^^^^^^^^^
src\core\simulation_runner.py:81: in get_step_fn
    return _load_full_step() if use_full else _load_lowrank_step()
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_full_step():
        """
        Attempt to load the full dynamics ``step`` function.
    
        Returns
        -------
        callable
            The ``step(x, u, dt)`` function from the full dynamics module.
    
        Raises
        ------
        RuntimeError
            If the module cannot be imported or does not define ``step``.
        """
        try:
            mod = import_module(DYNAMICS_FULL_MODULE)
            return getattr(mod, "step")
        except Exception:
            # EXACT message required by tests:
&gt;           raise RuntimeError(
                "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"
            )
E           RuntimeError: Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py

src\core\simulation_runner.py:55: RuntimeError

During handling of the above exception, another exception occurred:

    def test_simulate_nan_guard_raises():
        # Build a trajectory that injects NaN at the second state (manually)
        # simulate checks guards on the provided state sequence, so create a control
        # sequence and then modify the state via a custom stop_fn to trigger NaN.
        x0 = np.array([0.0, 0.0])
        u = np.array([0.0, 0.0])
    
        # There is no hook to inject states into simulate, so emulate the guard directly
        # by calling _guard_no_nan via simulate's internals: easiest path is to provide
        # NaN initial state.
&gt;       with pytest.raises(RuntimeError, match="NaN detected in state at step &lt;i&gt;"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: Regex pattern did not match.
E        Regex: 'NaN detected in state at step &lt;i&gt;'
E        Input: "Full dynamics unavailable: module 'dynamics_full' not found. Set config.simulation.use_full_dynamics=false or provide src/core/dynamics_full.py"

tests\test_core\test_vector_sim_guards.py:43: AssertionError</failure></testcase><testcase classname="tests.test_core.test_vector_sim_guards" name="test_simulate_system_batch_early_stops_scalar" time="0.001" /><testcase classname="tests.test_core.test_vector_sim_guards" name="test_simulate_system_batch_early_stops_batch" time="0.001" /><testcase classname="tests.test_fault_detection.test_fdi" name="test_fdi_trips_after_persistence" time="0.001" /><testcase classname="tests.test_fault_detection.test_fdi" name="test_fdi_resets_counter_on_good_measurement" time="0.001" /><testcase classname="tests.test_fault_detection.test_fdi" name="test_fdi_no_false_alarm" time="0.002" /><testcase classname="tests.test_fault_detection.test_fdi" name="test_fdi_dt_validation" time="0.001" /><testcase classname="tests.test_hil.test_hil" name="test_struct_compatibility" time="0.001" /><testcase classname="tests.test_hil.test_hil" name="test_plant_server_sets_ready_event" time="1.014" /><testcase classname="tests.test_hil.test_hil" name="test_hil_udp_roundtrip" time="0.270" /><testcase classname="tests.test_hil.test_hil" name="test_udp_port_released_after_server_stop" time="0.140" /><testcase classname="tests.test_hil.test_hil" name="test_missing_config_path_raises" time="0.004" /><testcase classname="tests.test_hil.test_hil_readiness_timeout" name="test_hil_raises_when_server_never_ready" time="0.004"><failure message="AttributeError: 'Cfg' object has no attribute 'hil'">tmp_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_hil_raises_when_server_ne0')
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E21B020&gt;

    def test_hil_raises_when_server_never_ready(tmp_path, monkeypatch):
        from app import _run_hil
    
        cfg_path = _write_cfg(tmp_path / "hil_timeout.yaml")
    
        # Patch PlantServer.start to never set the ready event and just sleep a bit
        import src.hil.plant_server as plant_mod
    
        original_start = plant_mod.PlantServer.start
    
        def fake_start(self):  # noqa: ANN001
            # Do not set self._ready_evt; just sleep shorter than the wait timeout
            time.sleep(0.5)
            # Return without touching sockets
            return None
    
        monkeypatch.setattr(plant_mod.PlantServer, "start", fake_start)
        # Also bypass baseline simulation so the test focuses on readiness
        import app as app_mod
    
        def _noop_baseline(_args):  # noqa: ANN001
            return 0
    
        monkeypatch.setattr(app_mod, "_run_simulation_and_plot", _noop_baseline)
    
        with pytest.raises(RuntimeError, match="failed to signal readiness"):
&gt;           _run_hil(cfg_path, do_plot=False)

tests\test_hil\test_hil_readiness_timeout.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cfg_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_hil_raises_when_server_ne0/hil_timeout.yaml')
do_plot = False

    def _run_hil(cfg_path: Path, do_plot: bool) -&gt; int:
        """
        Spawns the plant server and controller client, ensuring robust resource
        cleanup. Baseline simulation is executed prior to establishing the
        networked HIL run unless the caller has explicitly set ``TEST_MODE`` in
        the environment. Any unexpected exception raised during baseline
        simulation or orchestration is allowed to propagate to the caller (via
        ``main``), ensuring fail‑fast behaviour. Cleanup of server and client
        resources is always attempted in the ``finally`` block.
        """
        # Declare resources up front for cleanup in the finally block
        server: Optional[Any] = None
        server_thread: Optional[threading.Thread] = None
        client_proc: Optional[subprocess.Popen] = None
        # Default return code if the client process runs and finishes cleanly
        retcode: int = 1
        # Duration for the HIL run (may be overridden by configuration)
        duration: float = 5.0
        # Fail fast if the configuration file does not exist.  Without this
        # precondition the code proceeds to load the config and fails later
        # with an AttributeError, which obscures the true cause of the error.
        if not Path(cfg_path).is_file():
            raise FileNotFoundError(f"Configuration file not found: {Path(cfg_path).absolute()}")
        try:
            # 1) Load HIL‑specific modules and a validated config. Let import
            # errors propagate to the caller; they will be caught by ``main`` if
            # appropriate.
            from src.hil.plant_server import PlantServer  # type: ignore
            from src.config import load_config  # type: ignore
            from pydantic import ValidationError  # type: ignore
    
            try:
                cfg_obj = load_config(cfg_path, allow_unknown=True)
            except ValidationError as e:
                # Log validation errors and re‑raise to propagate. A validation
                # failure in the configuration should cause the application to
                # terminate with a non‑zero exit code, so we log each error and
                # then re‑raise.
                logging.error(
                    "Config validation failed for HIL run. See details below:"
                )
                for err in e.errors():
                    loc = ".".join(map(str, err.get("loc", [])))
                    msg = err.get("msg", "invalid value")
                    bad = err.get("input", "&lt;unknown&gt;")
                    logging.error(f" - {loc}: {msg}; got: {bad}")
                raise
    
            # Strongly‑typed reads from the validated configuration
&gt;           plant_ip = cfg_obj.hil.plant_ip
                       ^^^^^^^^^^^
E           AttributeError: 'Cfg' object has no attribute 'hil'

app.py:530: AttributeError</failure></testcase><testcase classname="tests.test_integration.test_settings_precedence" name="test_env_overrides_file" time="0.064"><failure message="src.config.InvalidConfigurationError: Configuration validation failed:&#10;  - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - simulation.dt: Input should be a valid number">path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
&gt;               cfg = ConfigSchema()
                      ^^^^^^^^^^^^^^

src\config.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = ConfigSchema(), _case_sensitive = None
_nested_model_default_partial_update = None, _env_prefix = None
_env_file = WindowsPath('.'), _env_file_encoding = None
_env_ignore_empty = None, _env_nested_delimiter = None
_env_nested_max_split = None, _env_parse_none_str = None
_env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None
_cli_hide_none_type = None, _cli_avoid_json = None, _cli_enforce_required = None
_cli_use_class_docs_for_groups = None, _cli_exit_on_error = None
_cli_prefix = None, _cli_flag_prefix_char = None, _cli_implicit_flags = None
_cli_ignore_unknown_args = None, _cli_kebab_case = None, _cli_shortcuts = None
_secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -&gt; None:
&gt;       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 6 validation errors for ConfigSchema
E       controllers.classical_smc
E         Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'boundary_layer': 0.02}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.sta_smc
E         Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'damping_gain': 0.0, 'ma...ce': 150.0, 'dt': 0.001}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.adaptive_smc
E         Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'lea..., 'boundary_layer': 0.1}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.swing_up_smc
E         Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'stabilizing_controller'...0.4, 'max_force': 150.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.hybrid_adaptive_sta_smc
E         Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'dt'...0, 'cart_p_lambda': 2.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       simulation.dt
E         Input should be a valid number [type=float_type, input_value='0.005', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/float_type

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic_settings\main.py:188: ValidationError

The above exception was the direct cause of the following exception:

monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E21B980&gt;

    def test_env_overrides_file(monkeypatch: pytest.MonkeyPatch):
        """ENV should override values coming from the config file."""
        repo_root = _repo_root_from_here()
        cfg_path = repo_root / "config.yaml"
        assert cfg_path.exists()
    
        monkeypatch.setenv("C04__SIMULATION__DT", "0.005")
&gt;       cfg = load_config(str(cfg_path))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_integration\test_settings_precedence.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
                cfg = ConfigSchema()
                logger.info(f"Configuration loaded from sources: ENV &gt; .env &gt; {file_path or 'defaults'}")
    
                # Global seeding
                try:
                    if getattr(cfg, "global_seed", None) is not None:
                        set_global_seed(cfg.global_seed)
                        logger.debug(f"Set global seed to {cfg.global_seed}")
                except Exception as e:
                    logger.warning(f"Failed to set global seed: {e}")
    
                return cfg
    
            except Exception as e:
                # Aggregate and redact
                error_messages: List[str] = []
                if hasattr(e, "errors"):
                    for err in e.errors():
                        loc = ".".join(str(x) for x in err.get("loc", []))
                        msg = err.get("msg", "Unknown error")
                        if "input" in err:
                            err["input"] = redact_value(err["input"])
                        error_messages.append(f"  - {loc}: {msg}")
                        logger.error(f"Validation error at {loc}: {msg}")
                else:
                    error_messages.append(str(e))
                    logger.error(f"Configuration error: {e}")
    
&gt;               raise InvalidConfigurationError(
                    "Configuration validation failed:\n" + "\n".join(error_messages)
                ) from e
E               src.config.InvalidConfigurationError: Configuration validation failed:
E                 - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - simulation.dt: Input should be a valid number

src\config.py:510: InvalidConfigurationError</failure></testcase><testcase classname="tests.test_integration.test_settings_precedence" name="test_dotenv_overrides_file_but_not_env" time="0.055"><failure message="src.config.InvalidConfigurationError: Configuration validation failed:&#10;  - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - simulation.dt: Input should be a valid number">path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
&gt;               cfg = ConfigSchema()
                      ^^^^^^^^^^^^^^

D:\Projects\main\DIP_SMC_PSO\src\config.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = ConfigSchema(), _case_sensitive = None
_nested_model_default_partial_update = None, _env_prefix = None
_env_file = WindowsPath('.'), _env_file_encoding = None
_env_ignore_empty = None, _env_nested_delimiter = None
_env_nested_max_split = None, _env_parse_none_str = None
_env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None
_cli_hide_none_type = None, _cli_avoid_json = None, _cli_enforce_required = None
_cli_use_class_docs_for_groups = None, _cli_exit_on_error = None
_cli_prefix = None, _cli_flag_prefix_char = None, _cli_implicit_flags = None
_cli_ignore_unknown_args = None, _cli_kebab_case = None, _cli_shortcuts = None
_secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -&gt; None:
&gt;       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 6 validation errors for ConfigSchema
E       controllers.classical_smc
E         Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'boundary_layer': 0.02}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.sta_smc
E         Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'damping_gain': 0.0, 'ma...ce': 150.0, 'dt': 0.001}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.adaptive_smc
E         Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'lea..., 'boundary_layer': 0.1}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.swing_up_smc
E         Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'stabilizing_controller'...0.4, 'max_force': 150.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.hybrid_adaptive_sta_smc
E         Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'dt'...0, 'cart_p_lambda': 2.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       simulation.dt
E         Input should be a valid number [type=float_type, input_value='0.003', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.11/v/float_type

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic_settings\main.py:188: ValidationError

The above exception was the direct cause of the following exception:

tmp_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_dotenv_overrides_file_but0')
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E2D4670&gt;

    def test_dotenv_overrides_file_but_not_env(tmp_path: Path, monkeypatch: pytest.MonkeyPatch):
        """.env should override file, but real ENV must still have highest precedence."""
        repo_root = _repo_root_from_here()
        cfg_path = repo_root / "config.yaml"
        assert cfg_path.exists()
    
        dotenv_file = tmp_path / ".env"
        dotenv_file.write_text("C04__SIMULATION__DT=0.010\n", encoding="utf-8")
    
        monkeypatch.chdir(tmp_path)
        monkeypatch.setenv("C04__SIMULATION__DT", "0.003")
&gt;       cfg = load_config(str(cfg_path))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^

D:\Projects\main\DIP_SMC_PSO\tests\test_integration\test_settings_precedence.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
                cfg = ConfigSchema()
                logger.info(f"Configuration loaded from sources: ENV &gt; .env &gt; {file_path or 'defaults'}")
    
                # Global seeding
                try:
                    if getattr(cfg, "global_seed", None) is not None:
                        set_global_seed(cfg.global_seed)
                        logger.debug(f"Set global seed to {cfg.global_seed}")
                except Exception as e:
                    logger.warning(f"Failed to set global seed: {e}")
    
                return cfg
    
            except Exception as e:
                # Aggregate and redact
                error_messages: List[str] = []
                if hasattr(e, "errors"):
                    for err in e.errors():
                        loc = ".".join(str(x) for x in err.get("loc", []))
                        msg = err.get("msg", "Unknown error")
                        if "input" in err:
                            err["input"] = redact_value(err["input"])
                        error_messages.append(f"  - {loc}: {msg}")
                        logger.error(f"Validation error at {loc}: {msg}")
                else:
                    error_messages.append(str(e))
                    logger.error(f"Configuration error: {e}")
    
&gt;               raise InvalidConfigurationError(
                    "Configuration validation failed:\n" + "\n".join(error_messages)
                ) from e
E               src.config.InvalidConfigurationError: Configuration validation failed:
E                 - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - simulation.dt: Input should be a valid number

D:\Projects\main\DIP_SMC_PSO\src\config.py:510: InvalidConfigurationError</failure></testcase><testcase classname="tests.test_integration.test_settings_precedence" name="test_file_used_when_no_env_or_dotenv" time="0.047"><failure message="src.config.InvalidConfigurationError: Configuration validation failed:&#10;  - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.&#10;  - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.">path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
&gt;               cfg = ConfigSchema()
                      ^^^^^^^^^^^^^^

src\config.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

__pydantic_self__ = ConfigSchema(), _case_sensitive = None
_nested_model_default_partial_update = None, _env_prefix = None
_env_file = WindowsPath('.'), _env_file_encoding = None
_env_ignore_empty = None, _env_nested_delimiter = None
_env_nested_max_split = None, _env_parse_none_str = None
_env_parse_enums = None, _cli_prog_name = None, _cli_parse_args = None
_cli_settings_source = None, _cli_parse_none_str = None
_cli_hide_none_type = None, _cli_avoid_json = None, _cli_enforce_required = None
_cli_use_class_docs_for_groups = None, _cli_exit_on_error = None
_cli_prefix = None, _cli_flag_prefix_char = None, _cli_implicit_flags = None
_cli_ignore_unknown_args = None, _cli_kebab_case = None, _cli_shortcuts = None
_secrets_dir = None, values = {}

    def __init__(
        __pydantic_self__,
        _case_sensitive: bool | None = None,
        _nested_model_default_partial_update: bool | None = None,
        _env_prefix: str | None = None,
        _env_file: DotenvType | None = ENV_FILE_SENTINEL,
        _env_file_encoding: str | None = None,
        _env_ignore_empty: bool | None = None,
        _env_nested_delimiter: str | None = None,
        _env_nested_max_split: int | None = None,
        _env_parse_none_str: str | None = None,
        _env_parse_enums: bool | None = None,
        _cli_prog_name: str | None = None,
        _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,
        _cli_settings_source: CliSettingsSource[Any] | None = None,
        _cli_parse_none_str: str | None = None,
        _cli_hide_none_type: bool | None = None,
        _cli_avoid_json: bool | None = None,
        _cli_enforce_required: bool | None = None,
        _cli_use_class_docs_for_groups: bool | None = None,
        _cli_exit_on_error: bool | None = None,
        _cli_prefix: str | None = None,
        _cli_flag_prefix_char: str | None = None,
        _cli_implicit_flags: bool | None = None,
        _cli_ignore_unknown_args: bool | None = None,
        _cli_kebab_case: bool | None = None,
        _cli_shortcuts: Mapping[str, str | list[str]] | None = None,
        _secrets_dir: PathType | None = None,
        **values: Any,
    ) -&gt; None:
&gt;       super().__init__(
            **__pydantic_self__._settings_build_values(
                values,
                _case_sensitive=_case_sensitive,
                _nested_model_default_partial_update=_nested_model_default_partial_update,
                _env_prefix=_env_prefix,
                _env_file=_env_file,
                _env_file_encoding=_env_file_encoding,
                _env_ignore_empty=_env_ignore_empty,
                _env_nested_delimiter=_env_nested_delimiter,
                _env_nested_max_split=_env_nested_max_split,
                _env_parse_none_str=_env_parse_none_str,
                _env_parse_enums=_env_parse_enums,
                _cli_prog_name=_cli_prog_name,
                _cli_parse_args=_cli_parse_args,
                _cli_settings_source=_cli_settings_source,
                _cli_parse_none_str=_cli_parse_none_str,
                _cli_hide_none_type=_cli_hide_none_type,
                _cli_avoid_json=_cli_avoid_json,
                _cli_enforce_required=_cli_enforce_required,
                _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,
                _cli_exit_on_error=_cli_exit_on_error,
                _cli_prefix=_cli_prefix,
                _cli_flag_prefix_char=_cli_flag_prefix_char,
                _cli_implicit_flags=_cli_implicit_flags,
                _cli_ignore_unknown_args=_cli_ignore_unknown_args,
                _cli_kebab_case=_cli_kebab_case,
                _cli_shortcuts=_cli_shortcuts,
                _secrets_dir=_secrets_dir,
            )
        )
E       pydantic_core._pydantic_core.ValidationError: 5 validation errors for ConfigSchema
E       controllers.classical_smc
E         Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'boundary_layer': 0.02}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.sta_smc
E         Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'damping_gain': 0.0, 'ma...ce': 150.0, 'dt': 0.001}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.adaptive_smc
E         Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'lea..., 'boundary_layer': 0.1}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.swing_up_smc
E         Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'stabilizing_controller'...0.4, 'max_force': 150.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error
E       controllers.hybrid_adaptive_sta_smc
E         Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys. [type=value_error, input_value={'max_force': 150.0, 'dt'...0, 'cart_p_lambda': 2.0}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/value_error

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic_settings\main.py:188: ValidationError

The above exception was the direct cause of the following exception:

monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002900E2D6CF0&gt;

    def test_file_used_when_no_env_or_dotenv(monkeypatch: pytest.MonkeyPatch):
        """When no ENV/.env, fall back to file value."""
        repo_root = _repo_root_from_here()
        cfg_path = repo_root / "config.yaml"
        assert cfg_path.exists()
    
        monkeypatch.delenv("C04__SIMULATION__DT", raising=False)
&gt;       cfg = load_config(str(cfg_path))
              ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_integration\test_settings_precedence.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = 'D:\\Projects\\main\\DIP_SMC_PSO\\config.yaml'

    def load_config(
        path: str | Path = "config.yaml",
        *,
        allow_unknown: bool = False,
    ) -&gt; ConfigSchema:
        """
        Load, parse, and validate configuration with precedence:
          1) Environment variables (C04__ prefix)
          2) .env file (if present)
          3) YAML/JSON file at `path` (if present)
          4) Model defaults
    
        Parameters
        ----------
        path : str | Path
            Path to YAML or JSON configuration file (optional).
        allow_unknown : bool
            If True, unknown keys in controller configs will be accepted and collected.
    
        Raises
        ------
        InvalidConfigurationError
            When validation fails. Aggregates error messages with dot-paths.
        """
        # Remember current permissive flag and set for this call
        previous_allow = bool(getattr(PermissiveControllerConfig, "allow_unknown", False))
        PermissiveControllerConfig.allow_unknown = bool(allow_unknown)
        try:
            file_path = Path(path) if path else None
            if file_path and not file_path.exists():
                logger.warning(f"Configuration file not found: {file_path.absolute()}")
    
            if Path(".env").exists():
                load_dotenv(".env", override=False)
                logger.debug("Loaded .env file")
    
            # Attach file path so settings_customise_sources can see it
            ConfigSchema._file_path = file_path  # type: ignore[attr-defined]
    
            try:
                cfg = ConfigSchema()
                logger.info(f"Configuration loaded from sources: ENV &gt; .env &gt; {file_path or 'defaults'}")
    
                # Global seeding
                try:
                    if getattr(cfg, "global_seed", None) is not None:
                        set_global_seed(cfg.global_seed)
                        logger.debug(f"Set global seed to {cfg.global_seed}")
                except Exception as e:
                    logger.warning(f"Failed to set global seed: {e}")
    
                return cfg
    
            except Exception as e:
                # Aggregate and redact
                error_messages: List[str] = []
                if hasattr(e, "errors"):
                    for err in e.errors():
                        loc = ".".join(str(x) for x in err.get("loc", []))
                        msg = err.get("msg", "Unknown error")
                        if "input" in err:
                            err["input"] = redact_value(err["input"])
                        error_messages.append(f"  - {loc}: {msg}")
                        logger.error(f"Validation error at {loc}: {msg}")
                else:
                    error_messages.append(str(e))
                    logger.error(f"Configuration error: {e}")
    
&gt;               raise InvalidConfigurationError(
                    "Configuration validation failed:\n" + "\n".join(error_messages)
                ) from e
E               src.config.InvalidConfigurationError: Configuration validation failed:
E                 - controllers.classical_smc: Value error, Unknown configuration keys: boundary_layer, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.sta_smc: Value error, Unknown configuration keys: damping_gain, dt, max_force. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.adaptive_smc: Value error, Unknown configuration keys: K_max, K_min, adapt_rate_limit, boundary_layer, dead_zone, dt, leak_rate, max_force, smooth_switch. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.swing_up_smc: Value error, Unknown configuration keys: energy_gain, exit_energy_factor, max_force, reentry_angle_tolerance, stabilizing_controller, switch_angle_tolerance, switch_energy_factor. Set allow_unknown=True when calling load_config to accept unknown keys.
E                 - controllers.hybrid_adaptive_sta_smc: Value error, Unknown configuration keys: adapt_rate_limit, cart_gain, cart_lambda, cart_p_gain, cart_p_lambda, damping_gain, dead_zone, dt, enable_equivalent, gamma1, gamma2, k1_init, k2_init, max_force, sat_soft_width. Set allow_unknown=True when calling load_config to accept unknown keys.

src\config.py:510: InvalidConfigurationError</failure></testcase><testcase classname="tests.test_logging_no_basicconfig" name="test_no_basicConfig_on_import" time="0.007"><failure message="DeprecationWarning: Import moved to src.benchmarks.statistical_benchmarks">monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x000002907EF4B1E0&gt;

    def test_no_basicConfig_on_import(monkeypatch):
        """Test that no library imports call logging.basicConfig."""
        called = False
    
        def fake_basicConfig(*a, **kw):
            nonlocal called
            called = True
    
        monkeypatch.setattr(logging, "basicConfig", fake_basicConfig)
    
        src_dir = Path("src")
        assert src_dir.exists()
    
        for pkg in src_dir.iterdir():
            if pkg.is_dir() and (pkg / "__init__.py").exists():
                root_name = pkg.name
                skip_suffixes = (".cli", ".app")
                for m in pkgutil.walk_packages([str(pkg)], prefix=f"{root_name}."):
                    if any(m.name.endswith(s) for s in skip_suffixes):
                        continue
&gt;                   importlib.import_module(m.name)

tests\test_logging_no_basicconfig.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1331: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:935: in _load_unlocked
    ???
&lt;frozen importlib._bootstrap_external&gt;:1026: in exec_module
    ???
&lt;frozen importlib._bootstrap&gt;:488: in _call_with_frames_removed
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    # benchmarks/statistical_benchmarks.py (shim)
    import warnings
&gt;   warnings.warn("Import moved to src.benchmarks.statistical_benchmarks", DeprecationWarning, stacklevel=2)
E   DeprecationWarning: Import moved to src.benchmarks.statistical_benchmarks

benchmarks\statistical_benchmarks.py:3: DeprecationWarning</failure></testcase><testcase classname="tests.test_mpl_enforcement" name="test_backend_is_agg" time="0.001" /><testcase classname="tests.test_mpl_enforcement" name="test_show_is_banned" time="0.002" /><testcase classname="tests.test_optimizer.test_cli_determinism" name="test_cli_stdout_is_deterministic" time="1.851"><failure message="AssertionError: CLI failed (code=1).&#10;  STDOUT:&#10;  &#10;  STDERR:&#10;  ERROR:root:Application failed with a critical error: Deprecated PSO configuration fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.&#10;  Traceback (most recent call last):&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\app.py&quot;, line 700, in main&#10;      return _run_pso(run_args)&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\app.py&quot;, line 369, in _run_pso&#10;      tuner = PSOTuner(controller_factory, config=cfg, seed=seed_to_use)&#10;    File &quot;D:\Projects\main\DIP_SMC_PSO\src\optimizer\pso_optimizer.py&quot;, line 193, in __init__&#10;      raise ValueError(&#10;      ...&lt;2 lines&gt;...&#10;      )&#10;  ValueError: Deprecated PSO configuration fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.&#10;  &#10;assert 1 == 0&#10; +  where 1 = CompletedProcess(args=['C:\\Users\\sadeg\\AppData\\Local\\Programs\\Python\\Python313\\python.exe', 'D:\\Projects\\mai...ation fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.\n').returncode">tmp_path = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_cli_stdout_is_determinist1')

    @pytest.mark.slow
    def test_cli_stdout_is_deterministic(tmp_path: Path):
        app = _find_repo_file("app.py")
        cfg_src = _find_repo_file("config.yaml")
        if not app.exists():
            pytest.skip("app.py not found; skipping CLI determinism test.")
    
        # Create a fast config for testing
        cfg = tmp_path / "config.yaml"
        _create_fast_config(cfg_src, cfg)
    
&gt;       out1 = _run_cli(app, cfg)
               ^^^^^^^^^^^^^^^^^^

tests\test_optimizer\test_cli_determinism.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

app = WindowsPath('D:/Projects/main/DIP_SMC_PSO/app.py')
config = WindowsPath('C:/Users/sadeg/AppData/Local/Temp/pytest-of-sadeg/pytest-203/test_cli_stdout_is_determinist1/config.yaml')

    def _run_cli(app: Path, config: Path) -&gt; str:
        # Set TEST_MODE to force fast mode
        env = os.environ.copy()
        env["TEST_MODE"] = "1"
    
        cmd = [
            sys.executable, str(app),
            "--run-pso",
            "--controller", "classical_smc",
            "--config", str(config),
            "--seed", "123",
        ]
    
        proc = subprocess.run(
            cmd,
            cwd=app.parent,
            capture_output=True,
            text=True,
            timeout=60,  # Give it a bit more time
            env=env
        )
&gt;       assert proc.returncode == 0, (
            f"CLI failed (code={proc.returncode}).\nSTDOUT:\n{proc.stdout}\nSTDERR:\n{proc.stderr}"
        )
E       AssertionError: CLI failed (code=1).
E         STDOUT:
E         
E         STDERR:
E         ERROR:root:Application failed with a critical error: Deprecated PSO configuration fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.
E         Traceback (most recent call last):
E           File "D:\Projects\main\DIP_SMC_PSO\app.py", line 700, in main
E             return _run_pso(run_args)
E           File "D:\Projects\main\DIP_SMC_PSO\app.py", line 369, in _run_pso
E             tuner = PSOTuner(controller_factory, config=cfg, seed=seed_to_use)
E           File "D:\Projects\main\DIP_SMC_PSO\src\optimizer\pso_optimizer.py", line 193, in __init__
E             raise ValueError(
E             ...&lt;2 lines&gt;...
E             )
E         ValueError: Deprecated PSO configuration fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.
E         
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['C:\\Users\\sadeg\\AppData\\Local\\Programs\\Python\\Python313\\python.exe', 'D:\\Projects\\mai...ation fields present: hyper_trials, hyper_search, study_timeout. Please remove these fields from the configuration.\n').returncode

tests\test_optimizer\test_cli_determinism.py:207: AssertionError</failure></testcase><testcase classname="tests.test_optimizer.test_pso_core" name="test_normalise_division_by_zero" time="0.001" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_normalise_regular_division" time="0.001" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_combine_costs_1d" time="0.002" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_combine_costs_2d" time="0.002" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_combine_costs_invalid_returns_penalty" time="0.003" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_iter_perturbed_physics_nominal" time="0.005" /><testcase classname="tests.test_optimizer.test_pso_core" name="test_iter_perturbed_physics_multiple" time="0.004" /><testcase classname="tests.test_optimizer.test_pso_enhancements" name="test_pso_velocity_clamp_passed" time="0.004"><failure message="ModuleNotFoundError: No module named 'pyswarms'">def test_pso_velocity_clamp_passed() -&gt; None:
        """PSOTuner should pass velocity_clamp to GlobalBestPSO with scaled limits."""
        cfg = _make_minimal_config(velocity_clamp=(0.1, 0.2))
        # Expected velocity limits: range = bmax - bmin = 1.0, so limits = (0.1, 0.2)
        expected_vclamp = (np.array([0.1]), np.array([0.2]))
        captured = {}
    
        class FakePSO:
            def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
                captured['velocity_clamp'] = kwargs.get('velocity_clamp')
                # Record options
                captured['options'] = kwargs.get('options')
                self.options = kwargs.get('options')
                self.swarm = type('Swarm', (), {'best_cost': 0.0, 'best_pos': np.zeros(1)})
    
            def optimize(self, fitness, iters: int):
                return 0.0, np.zeros(1)
    
        with patch('src.core.vector_sim.simulate_system_batch', dummy_simulate_system_batch):
&gt;           with patch('pyswarms.single.GlobalBestPSO', new=FakePSO):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_optimizer\test_pso_enhancements.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'pyswarms', import_ = &lt;function _gcd_import at 0x0000029068B704A0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'pyswarms'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_optimizer.test_pso_enhancements" name="test_pso_w_schedule_updates_inertia" time="0.005"><failure message="ModuleNotFoundError: No module named 'pyswarms'">def test_pso_w_schedule_updates_inertia() -&gt; None:
        """PSOTuner should update inertia weight according to w_schedule each step."""
        cfg = _make_minimal_config(w_schedule=(0.9, 0.4))
        w_history: list[float] = []
    
        class FakePSO:
            def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
                self.options = kwargs.get('options').copy()
                self.swarm = type('Swarm', (), {'best_cost': 0.0, 'best_pos': np.zeros(1)})
    
            def step(self, fitness):
                # Record current inertia weight
                w_history.append(float(self.options['w']))
                return 0.0, np.zeros(1)
    
            def optimize(self, fitness, iters: int):
                return 0.0, np.zeros(1)
    
        with patch('src.core.vector_sim.simulate_system_batch', dummy_simulate_system_batch):
&gt;           with patch('pyswarms.single.GlobalBestPSO', new=FakePSO):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_optimizer\test_pso_enhancements.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\unittest\mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'pyswarms', import_ = &lt;function _gcd_import at 0x0000029068B704A0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'pyswarms'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_optimizer.test_reoptimization_script" name="test_main_script_flow" time="0.008" /><testcase classname="tests.test_property_based" name="test_cross_field_acceptance_covered" time="0.056"><failure message="TypeError: unhashable type: 'types.SimpleNamespace'">@given(sc=st.lists(alpha, min_size=1, max_size=5))
&gt;   @settings(deadline=None, max_examples=50)
                   ^^^

tests\test_property_based.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:929: in run
    self._run()
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:1499: in _run
    self.generate_new_examples()
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:1202: in generate_new_examples
    prefix = self.generate_novel_prefix()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:722: in generate_novel_prefix
    return self.tree.generate_novel_prefix(self.random)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\datatree.py:783: in generate_novel_prefix
    node_value = self._draw(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\datatree.py:894: in _draw
    value = draw_choice(choice_type, constraints, random=random)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\data.py:1381: in draw_choice
    return cast(ChoiceT, getattr(cd.provider, f"draw_{choice_type}")(**constraints))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:893: in draw_string
    constant := self._maybe_draw_constant(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:694: in _maybe_draw_constant
    assert self._local_constants is not None
           ^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\functools.py:1026: in __get__
    val = self.func(instance)
          ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:677: in _local_constants
    return _get_local_constants()
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _get_local_constants() -&gt; Constants:
        global _sys_modules_len, _local_constants
    
        if sys.platform == "emscripten":  # pragma: no cover
            # pyodide builds bundle the stdlib in a nonstandard location, like
            # `/lib/python312.zip/heapq.py`. To avoid identifying the entirety of
            # the stdlib as local code and slowing down on emscripten, instead return
            # that nothing is local.
            #
            # pyodide may provide some way to distinguish stdlib/third-party/local
            # code. I haven't looked into it. If they do, we should correctly implement
            # ModuleLocation for pyodide instead of this.
            return _local_constants
    
        count_constants = len(_local_constants)
        # We call this function once per HypothesisProvider instance, i.e. once per
        # input, so it needs to be performant. The logic here is more complicated
        # than necessary because of this.
        #
        # First, we check whether there are any new modules with a very cheap length
        # check. This check can be fooled if a module is added while another module is
        # removed, but the more correct check against tuple(sys.modules.keys()) is
        # substantially more expensive. Such a new module would eventually be discovered
        # if / when the length changes again in the future.
        #
        # If the length has changed, we find just modules we haven't seen before. Of
        # those, we find the ones which correspond to local modules, and extract their
        # constants.
    
        # careful: store sys.modules length when we first check to avoid race conditions
        # with other threads loading a module before we set _sys_modules_len.
        if (sys_modules_len := len(sys.modules)) != _sys_modules_len:
            # set(_seen_modules) shouldn't typically be required, but I have run into
            # a "set changed size during iteration" error here when running
            # test_provider_conformance_crosshair.
&gt;           new_modules = set(sys.modules.values()) - set(_seen_modules)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: unhashable type: 'types.SimpleNamespace'

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:280: TypeError</failure></testcase><testcase classname="tests.test_property_based" name="test_cross_field_acceptance_missing_trips_error" time="0.021"><failure message="TypeError: unhashable type: 'types.SimpleNamespace'">@given(sc=st.lists(alpha, min_size=1, max_size=3))
&gt;   @settings(deadline=None, max_examples=50)
                   ^^^

tests\test_property_based.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:929: in run
    self._run()
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:1499: in _run
    self.generate_new_examples()
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:1202: in generate_new_examples
    prefix = self.generate_novel_prefix()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\engine.py:722: in generate_novel_prefix
    return self.tree.generate_novel_prefix(self.random)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\datatree.py:783: in generate_novel_prefix
    node_value = self._draw(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\datatree.py:894: in _draw
    value = draw_choice(choice_type, constraints, random=random)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\data.py:1381: in draw_choice
    return cast(ChoiceT, getattr(cd.provider, f"draw_{choice_type}")(**constraints))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:893: in draw_string
    constant := self._maybe_draw_constant(
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:694: in _maybe_draw_constant
    assert self._local_constants is not None
           ^^^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\functools.py:1026: in __get__
    val = self.func(instance)
          ^^^^^^^^^^^^^^^^^^^
C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:677: in _local_constants
    return _get_local_constants()
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _get_local_constants() -&gt; Constants:
        global _sys_modules_len, _local_constants
    
        if sys.platform == "emscripten":  # pragma: no cover
            # pyodide builds bundle the stdlib in a nonstandard location, like
            # `/lib/python312.zip/heapq.py`. To avoid identifying the entirety of
            # the stdlib as local code and slowing down on emscripten, instead return
            # that nothing is local.
            #
            # pyodide may provide some way to distinguish stdlib/third-party/local
            # code. I haven't looked into it. If they do, we should correctly implement
            # ModuleLocation for pyodide instead of this.
            return _local_constants
    
        count_constants = len(_local_constants)
        # We call this function once per HypothesisProvider instance, i.e. once per
        # input, so it needs to be performant. The logic here is more complicated
        # than necessary because of this.
        #
        # First, we check whether there are any new modules with a very cheap length
        # check. This check can be fooled if a module is added while another module is
        # removed, but the more correct check against tuple(sys.modules.keys()) is
        # substantially more expensive. Such a new module would eventually be discovered
        # if / when the length changes again in the future.
        #
        # If the length has changed, we find just modules we haven't seen before. Of
        # those, we find the ones which correspond to local modules, and extract their
        # constants.
    
        # careful: store sys.modules length when we first check to avoid race conditions
        # with other threads loading a module before we set _sys_modules_len.
        if (sys_modules_len := len(sys.modules)) != _sys_modules_len:
            # set(_seen_modules) shouldn't typically be required, but I have run into
            # a "set changed size during iteration" error here when running
            # test_provider_conformance_crosshair.
&gt;           new_modules = set(sys.modules.values()) - set(_seen_modules)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: unhashable type: 'types.SimpleNamespace'

C:\Users\sadeg\AppData\Local\Programs\Python\Python313\Lib\site-packages\hypothesis\internal\conjecture\providers.py:280: TypeError</failure></testcase><testcase classname="tests.test_property_based" name="test_unknown_field_injection_detected" time="0.001" /><testcase classname="tests.test_utils.test_control_analysis_module" name="test_control_analysis_full_rank" time="0.001"><failure message="assert np.True_ is True">def test_control_analysis_full_rank() -&gt; None:
        """A simple second‑order system with non‑zero input should be controllable and observable."""
        # Double integrator system
        A = np.array([[0.0, 1.0], [0.0, 0.0]])
        B = np.array([[0.0], [1.0]])
        C = np.eye(2)
        ctrl, obs = check_controllability_observability(A, B, C)
&gt;       assert ctrl is True
E       assert np.True_ is True

tests\test_utils\test_control_analysis_module.py:28: AssertionError</failure></testcase><testcase classname="tests.test_utils.test_control_analysis_module" name="test_control_analysis_rank_deficient" time="0.002"><failure message="assert np.False_ is False">def test_control_analysis_rank_deficient() -&gt; None:
        """A system with zero input matrix is uncontrollable but still observable with full output."""
        # Identity dynamics with no control influence
        A = np.eye(2)
        B = np.zeros((2, 1))
        C = np.eye(2)
        ctrl, obs = check_controllability_observability(A, B, C)
&gt;       assert ctrl is False
E       assert np.False_ is False

tests\test_utils\test_control_analysis_module.py:39: AssertionError</failure></testcase><testcase classname="tests.test_utils.test_control_primitives" name="test_saturate_tanh" time="0.001" /><testcase classname="tests.test_utils.test_control_primitives" name="test_saturate_linear" time="0.001"><failure message="RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.">def test_saturate_linear():
&gt;       assert saturate(10, 1, method='linear') == 1.0
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_utils\test_control_primitives.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sigma = 10, epsilon = 1, method = 'linear'

    def saturate(
        sigma: float | np.ndarray,
        epsilon: float,
        method: Literal["tanh", "linear"] = "tanh",
    ) -&gt; float | np.ndarray:
        """Continuous approximation of sign(sigma) within a boundary layer.
    
        Args:
            sigma: Sliding surface value(s).
            epsilon: Boundary-layer half-width in σ-space (must be &gt; 0).  # ε is the half-width in σ-space.
            method: "tanh" (default) uses tanh(sigma/epsilon);
                    "linear" uses clip(sigma/epsilon, -1, 1).
        Returns:
            Same shape as `sigma`.
    
        Notes
        -----
        The boundary layer width ``epsilon`` should be chosen based on the
        expected amplitude of measurement noise and the desired steady‑state
        accuracy.  A larger ``epsilon`` reduces chattering but introduces
        a finite steady‑state error; conversely, a smaller ``epsilon`` reduces
        error but may increase high‑frequency switching【538884328193976†L412-L423】.
    
        Raises:
            ValueError
                If ``epsilon &lt;= 0`` or an unknown ``method`` is provided.
        """
        if epsilon &lt;= 0:
            raise ValueError("boundary layer epsilon must be positive")
        s = np.asarray(sigma, dtype=float) / float(epsilon)
        if method == "tanh":
            return np.tanh(s)
        if method == "linear":
            # Warn users that the linear saturation approximates sign(sigma) poorly
            # near zero.  A piecewise‑linear approximation yields a sharp transition
            # at the boundary layer and can introduce larger steady‑state errors.
            # Sliding‑mode control theory recommends smooth approximations such
            # as tanh to mitigate chattering【676964782857750†L146-L149】.
            import warnings
&gt;           warnings.warn(
                "The 'linear' switching method implements a piecewise‑linear saturation, "
                "which approximates the sign function poorly near zero and can degrade "
                "chattering performance.  Consider using 'tanh' for smoother control.",
                RuntimeWarning,
            )
E           RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.

src\utils\control_primitives.py:145: RuntimeWarning</failure></testcase><testcase classname="tests.test_utils.test_control_primitives" name="test_saturate_zero_boundary" time="0.001" /><testcase classname="tests.test_utils.test_control_primitives_consolidated" name="test_control_primitives_core_behaviors" time="0.002"><failure message="RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.">def test_control_primitives_core_behaviors():
        # scalar tanh + linear basic
        assert np.isclose(saturate(0.0, 0.1), 0.0)
        assert saturate(100.0, 0.1) &gt; 0.999
        assert saturate(-100.0, 0.1) &lt; -0.999
&gt;       assert saturate(0.0, 1.0, method="linear") == 0.0
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_utils\test_control_primitives_consolidated.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sigma = 0.0, epsilon = 1.0, method = 'linear'

    def saturate(
        sigma: float | np.ndarray,
        epsilon: float,
        method: Literal["tanh", "linear"] = "tanh",
    ) -&gt; float | np.ndarray:
        """Continuous approximation of sign(sigma) within a boundary layer.
    
        Args:
            sigma: Sliding surface value(s).
            epsilon: Boundary-layer half-width in σ-space (must be &gt; 0).  # ε is the half-width in σ-space.
            method: "tanh" (default) uses tanh(sigma/epsilon);
                    "linear" uses clip(sigma/epsilon, -1, 1).
        Returns:
            Same shape as `sigma`.
    
        Notes
        -----
        The boundary layer width ``epsilon`` should be chosen based on the
        expected amplitude of measurement noise and the desired steady‑state
        accuracy.  A larger ``epsilon`` reduces chattering but introduces
        a finite steady‑state error; conversely, a smaller ``epsilon`` reduces
        error but may increase high‑frequency switching【538884328193976†L412-L423】.
    
        Raises:
            ValueError
                If ``epsilon &lt;= 0`` or an unknown ``method`` is provided.
        """
        if epsilon &lt;= 0:
            raise ValueError("boundary layer epsilon must be positive")
        s = np.asarray(sigma, dtype=float) / float(epsilon)
        if method == "tanh":
            return np.tanh(s)
        if method == "linear":
            # Warn users that the linear saturation approximates sign(sigma) poorly
            # near zero.  A piecewise‑linear approximation yields a sharp transition
            # at the boundary layer and can introduce larger steady‑state errors.
            # Sliding‑mode control theory recommends smooth approximations such
            # as tanh to mitigate chattering【676964782857750†L146-L149】.
            import warnings
&gt;           warnings.warn(
                "The 'linear' switching method implements a piecewise‑linear saturation, "
                "which approximates the sign function poorly near zero and can degrade "
                "chattering performance.  Consider using 'tanh' for smoother control.",
                RuntimeWarning,
            )
E           RuntimeWarning: The 'linear' switching method implements a piecewise‑linear saturation, which approximates the sign function poorly near zero and can degrade chattering performance.  Consider using 'tanh' for smoother control.

src\utils\control_primitives.py:145: RuntimeWarning</failure></testcase></testsuite></testsuites>