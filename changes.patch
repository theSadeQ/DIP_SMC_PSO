--- /home/oai/workspace/orig_repo/src/core/simulation_runner.py	2025-09-09 14:44:34.000000000 +0000
+++ /home/oai/workspace/src/core/simulation_runner.py	2025-09-09 15:53:45.529093034 +0000
@@ -14,6 +14,10 @@
 
 from importlib import import_module
 
+import time
+from typing import Any, Callable, Optional, Tuple
+import numpy as np
+
 # Attempt to import the configuration.  The config module must define an
 # attribute ``config.simulation.use_full_dynamics``.  We import lazily in
 # ``get_step_fn`` so that missing dependencies in ``src.config`` do not
@@ -95,3 +99,224 @@
         Next state computed by the selected dynamics implementation.
     """
     return get_step_fn()(x, u, dt)
+
+
+
+def run_simulation(
+    *,
+    controller: Any,
+    dynamics_model: Any,
+    sim_time: float,
+    dt: float,
+    initial_state: Any,
+    u_max: Optional[float] = None,
+    seed: Optional[int] = None,
+    rng: Optional[np.random.Generator] = None,
+    latency_margin: Optional[float] = None,
+    fallback_controller: Optional[Callable[[float, np.ndarray], float]] = None,
+    **_kwargs: Any,
+) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
+    """Simulate a single controller trajectory using an explicit Euler method.
+
+    The runner integrates the provided ``dynamics_model`` forward in time under
+    the control law defined by ``controller``.  It produces uniformly spaced
+    timestamps, a state trajectory and the applied control sequence.  If the
+    dynamics return NaN/Inf values or raise an exception at any step, the
+    simulation halts immediately and the outputs are truncated to include only
+    the steps executed.  Control inputs can be saturated via the ``u_max``
+    parameter or by querying ``controller.max_force`` when ``u_max`` is not
+    provided.  Stateful controllers may expose optional hooks
+    ``initialize_state`` and ``initialize_history``; these are called once at
+    the beginning of the simulation.  A ``compute_control`` method, if
+    available, is preferred over ``__call__`` for computing the control.  The
+    runner also supports a simple latency monitor: if computing the control
+    exceeds the nominal period ``dt`` on any step and a ``fallback_controller``
+    is provided, subsequent control inputs are drawn from the fallback.
+
+    Parameters
+    ----------
+    controller : Any
+        The control object.  Must implement ``__call__(t, x) -> float`` or
+        ``compute_control(x, state_vars, history)``.  Optional hooks
+        ``initialize_state`` and ``initialize_history`` may be defined to
+        initialise controller state.
+    dynamics_model : Any
+        Object providing a ``step(state, u, dt)`` method that advances the
+        state forward in time.  Must accept a state vector and scalar input
+        ``u``.
+    sim_time : float
+        Total simulation horizon in seconds.  The integration runs until
+        the largest multiple of ``dt`` not exceeding ``sim_time``.  A value
+        less than or equal to zero produces no integration steps.
+    dt : float
+        Integration timestep (seconds).  Must be strictly positive.
+    initial_state : array-like
+        Initial state vector.  Converted to ``float`` and flattened.  The
+        length of the state vector defines the dimensionality of the system.
+    u_max : float, optional
+        Saturation limit for the control input.  When provided, control
+        commands are clipped to the interval ``[-u_max, u_max]``.  If omitted
+        and the controller exposes ``max_force``, that value is used instead.
+    seed : int, optional
+        Deprecated.  Present for backward compatibility; use ``rng`` to
+        control randomness when required.  When both ``seed`` and ``rng`` are
+        provided, ``rng`` takes precedence.
+    rng : numpy.random.Generator, optional
+        Random number generator for controllers that rely on sampling.  If
+        provided, it is passed unchanged to the controller; otherwise a local
+        generator may be created when ``seed`` is supplied.
+    latency_margin : float, optional
+        Unused placeholder for future latency control.  Accepts any value
+        without effect.
+    fallback_controller : callable, optional
+        Function ``fallback_controller(t, x) -> float`` invoked to compute
+        control after a deadline miss.  When a control call exceeds ``dt`` in
+        duration, the fallback controller is used for all subsequent steps.
+    **_kwargs : dict
+        Additional keyword arguments are ignored.  They are accepted to
+        preserve backward compatibility with earlier versions of this API.
+
+    Returns
+    -------
+    t_arr : numpy.ndarray
+        1D array of time points including the initial time at index 0.  The
+        final element equals ``n_steps * dt`` where ``n_steps = int(round(sim_time / dt))``.
+    x_arr : numpy.ndarray
+        2D array of shape ``(len(t_arr), D)`` containing the state trajectory.
+    u_arr : numpy.ndarray
+        1D array of shape ``(len(t_arr) - 1,)`` containing the applied control
+        sequence.  Empty if no integration steps were executed.
+    """
+    # Normalise dt and horizon
+    dt = float(dt)
+    if dt <= 0.0:
+        raise ValueError("dt must be positive")
+    # Compute number of steps as the nearest integer that does not exceed sim_time
+    n_steps = int(round(float(sim_time) / dt)) if sim_time > 0 else 0
+    # Flatten the initial state to determine state dimension
+    x0 = np.asarray(initial_state, dtype=float).reshape(-1)
+    state_dim = x0.shape[0]
+    # Prepare output arrays
+    t_arr = np.zeros(n_steps + 1, dtype=float)
+    x_arr = np.zeros((n_steps + 1, state_dim), dtype=float)
+    u_arr = np.zeros(n_steps, dtype=float)
+    # Set initial conditions
+    t_arr[0] = 0.0
+    x_arr[0] = x0
+    # Determine control saturation limit
+    if u_max is not None:
+        try:
+            u_lim: Optional[float] = float(u_max)
+        except Exception:
+            u_lim = None
+    else:
+        if hasattr(controller, "max_force"):
+            try:
+                u_lim = float(getattr(controller, "max_force"))
+            except Exception:
+                u_lim = None
+        else:
+            u_lim = None
+    # Seed the random generator for backward compatibility
+    if rng is None and seed is not None:
+        try:
+            rng = np.random.default_rng(int(seed))
+        except Exception:
+            rng = None
+    # Initialise controller state and history if supported
+    ctrl_state = None
+    history = None
+    try:
+        if hasattr(controller, "initialize_state"):
+            ctrl_state = controller.initialize_state()  # type: ignore[assignment]
+    except Exception:
+        ctrl_state = None
+    try:
+        if hasattr(controller, "initialize_history"):
+            history = controller.initialize_history()  # type: ignore[assignment]
+    except Exception:
+        history = None
+    # Determine whether to use compute_control
+    use_compute = hasattr(controller, "compute_control")
+    # Latency monitor state: once an overrun is detected, engage fallback
+    use_fallback = False
+    # Main integration loop
+    x_curr = x0.copy()
+    for i in range(n_steps):
+        t_now = i * dt
+        # Compute control input
+        start_time = time.perf_counter()
+        try:
+            if use_fallback and fallback_controller is not None:
+                u_val = float(fallback_controller(t_now, x_curr))
+            else:
+                if use_compute:
+                    ret = controller.compute_control(x_curr, ctrl_state, history)  # type: ignore[attr-defined]
+                    try:
+                        u_val = float(ret[0])
+                    except Exception:
+                        u_val = float(ret)
+                    try:
+                        if len(ret) >= 2:
+                            ctrl_state = ret[1]
+                        if len(ret) >= 3:
+                            history = ret[2]
+                    except Exception:
+                        pass
+                else:
+                    u_val = float(controller(t_now, x_curr))
+        except Exception:
+            # Terminate on control exception
+            t_arr = t_arr[: i + 1]
+            x_arr = x_arr[: i + 1]
+            u_arr = u_arr[: i]
+            if history is not None:
+                try:
+                    setattr(controller, "_last_history", history)
+                except Exception:
+                    pass
+            return t_arr, x_arr, u_arr
+        end_time = time.perf_counter()
+        if (not use_fallback) and (fallback_controller is not None) and ((end_time - start_time) > dt):
+            use_fallback = True
+        # Saturate control
+        if u_lim is not None:
+            if u_val > u_lim:
+                u_val = u_lim
+            elif u_val < -u_lim:
+                u_val = -u_lim
+        u_arr[i] = u_val
+        # Propagate dynamics
+        try:
+            x_next = dynamics_model.step(x_curr, u_val, dt)
+        except Exception:
+            t_arr = t_arr[: i + 1]
+            x_arr = x_arr[: i + 1]
+            u_arr = u_arr[: i]
+            if history is not None:
+                try:
+                    setattr(controller, "_last_history", history)
+                except Exception:
+                    pass
+            return t_arr, x_arr, u_arr
+        x_next = np.asarray(x_next, dtype=float).reshape(-1)
+        if not np.all(np.isfinite(x_next)):
+            t_arr = t_arr[: i + 1]
+            x_arr = x_arr[: i + 1]
+            u_arr = u_arr[: i]
+            if history is not None:
+                try:
+                    setattr(controller, "_last_history", history)
+                except Exception:
+                    pass
+            return t_arr, x_arr, u_arr
+        t_arr[i + 1] = (i + 1) * dt
+        x_arr[i + 1] = x_next
+        x_curr = x_next
+    # Attach final history
+    if history is not None:
+        try:
+            setattr(controller, "_last_history", history)
+        except Exception:
+            pass
+    return t_arr, x_arr, u_arr
--- /home/oai/workspace/orig_repo/src/core/vector_sim.py	2025-09-09 14:45:15.000000000 +0000
+++ /home/oai/workspace/src/core/vector_sim.py	2025-09-09 15:53:45.533093350 +0000
@@ -174,3 +174,292 @@
     if not batch_mode:
         return result[0]
     return result
+
+
+
+def simulate_system_batch(
+    *,
+    controller_factory: Callable[[np.ndarray], Any],
+    particles: Any,
+    sim_time: float,
+    dt: float,
+    u_max: Optional[float] = None,
+    seed: Optional[int] = None,
+    params_list: Optional[Iterable[Any]] = None,
+    initial_state: Optional[Any] = None,
+    convergence_tol: Optional[float] = None,
+    grace_period: float = 0.0,
+    rng: Optional[np.random.Generator] = None,
+    **_kwargs: Any,
+) -> Any:
+    """Vectorised batch simulation of multiple controllers.
+
+    This function wraps ``run_simulation`` to simultaneously simulate a batch
+    of controllers with distinct gain vectors (``particles``).  It returns
+    time, state, control and sliding-surface arrays for the entire batch.
+    Optional early stopping is available: once the magnitude of the sliding
+    surface ``sigma`` falls below ``convergence_tol`` for all particles (after
+    a grace period), integration halts early and the outputs are truncated.
+
+    When ``params_list`` is provided, the simulation is repeated for each
+    element in the list.  The return value is then a list of results, one per
+    parameter set.  For backward compatibility, the dynamics model is
+    determined internally by the controller factory; perturbed physics
+    parameters are ignored and results are replicated across the list.
+
+    Parameters
+    ----------
+    controller_factory : callable
+        Factory ``controller_factory(p)`` that returns a controller given a
+        gain vector ``p``.  The returned controller must expose a
+        ``dynamics_model`` attribute defining the system dynamics.
+    particles : array-like
+        Array of shape ``(B, G)`` where each row contains a gain vector for
+        one particle.  A single particle may be provided as shape ``(G,)``.
+    sim_time : float
+        Total simulation duration (seconds).
+    dt : float
+        Timestep for integration (seconds).
+    u_max : float, optional
+        Control saturation limit.  Overrides controller-specific ``max_force``.
+    seed : int, optional
+        Deprecated.  Ignored; retained for signature compatibility.
+    params_list : iterable, optional
+        Optional list of physics parameter objects.  When provided, the
+        simulation is repeated for each element.  The current implementation
+        ignores these parameters and replicates the base results.
+    initial_state : array-like, optional
+        Initial state(s) for the batch.  If ``None``, a zero state is used.
+        If a 1D array of length ``D`` is provided, it is broadcast across all
+        particles.  If a 2D array of shape ``(B, D)`` is provided, it is used
+        directly.
+    convergence_tol : float, optional
+        Threshold for sliding-surface convergence.  When provided and
+        positive, the integration stops once ``max(|sigma|) < convergence_tol``
+        across all particles (after the grace period).
+    grace_period : float, optional
+        Duration (seconds) to wait before checking the convergence criterion.
+    rng : numpy.random.Generator, optional
+        Unused in this implementation.  Present for API compatibility.
+
+    Returns
+    -------
+    If ``params_list`` is not provided, returns a tuple ``(t, x_b, u_b, sigma_b)``:
+    
+    - ``t``: ndarray of shape ``(N+1,)`` of time points
+    - ``x_b``: ndarray of shape ``(B, N+1, D)`` of states
+    - ``u_b``: ndarray of shape ``(B, N)`` of controls
+    - ``sigma_b``: ndarray of shape ``(B, N)`` of sliding-surface values
+
+    If ``params_list`` is provided, returns a list of such tuples (one per
+    element in ``params_list``).
+    """
+    import numpy as _np  # local import to avoid polluting namespace
+    # Convert particles to array
+    part_arr = _np.asarray(particles, dtype=float)
+    if part_arr.ndim == 1:
+        part_arr = part_arr[_np.newaxis, :]
+    B, G = part_arr.shape
+    # Determine number of steps
+    dt = float(dt)
+    sim_time = float(sim_time)
+    H = int(round(sim_time / dt)) if sim_time > 0 else 0
+    # Instantiate controllers for each particle
+    controllers = []
+    for j in range(B):
+        try:
+            ctrl = controller_factory(part_arr[j])
+        except Exception:
+            ctrl = controller_factory(part_arr[j])
+        controllers.append(ctrl)
+    # Determine state dimension from first controller's dynamics model
+    if initial_state is None:
+        # Try to introspect state dimension
+        state_dim = None
+        try:
+            state_dim = int(getattr(controllers[0], "state_dim"))
+        except Exception:
+            try:
+                state_dim = int(getattr(controllers[0], "dynamics_model").state_dim)
+            except Exception:
+                state_dim = 6  # fall back to DIP dimension
+        init_b = _np.zeros((B, state_dim), dtype=float)
+    else:
+        init = _np.asarray(initial_state, dtype=float)
+        if init.ndim == 1:
+            # broadcast across batch
+            init_b = _np.broadcast_to(init, (B, init.shape[0])).copy()
+        else:
+            init_b = init.copy()
+    # Preallocate outputs
+    t_arr = _np.zeros(H + 1, dtype=float)
+    x_b = _np.zeros((B, H + 1, init_b.shape[1]), dtype=float)
+    u_b = _np.zeros((B, H), dtype=float)
+    sigma_b = _np.zeros((B, H), dtype=float)
+    x_b[:, 0, :] = init_b
+    # Convergence parameters
+    check_convergence = (convergence_tol is not None) and (convergence_tol is not False)
+    conv_tol = float(convergence_tol) if convergence_tol else 0.0
+    grace_steps = int(round(float(grace_period) / dt)) if grace_period > 0 else 0
+    # Per-controller state and history
+    state_vars = [None] * B
+    histories = [None] * B
+    for j, ctrl in enumerate(controllers):
+        try:
+            if hasattr(ctrl, "initialize_state"):
+                state_vars[j] = ctrl.initialize_state()  # type: ignore[assignment]
+        except Exception:
+            state_vars[j] = None
+        try:
+            if hasattr(ctrl, "initialize_history"):
+                histories[j] = ctrl.initialize_history()  # type: ignore[assignment]
+        except Exception:
+            histories[j] = None
+    # Determine per-particle saturation limits
+    u_limits = _np.full(B, _np.inf, dtype=float)
+    if u_max is not None:
+        u_limits[:] = float(u_max)
+    else:
+        for j, ctrl in enumerate(controllers):
+            if hasattr(ctrl, "max_force"):
+                try:
+                    u_limits[j] = float(getattr(ctrl, "max_force"))
+                except Exception:
+                    u_limits[j] = _np.inf
+    # Simulation loop
+    # We will reuse dynamics_model from each controller
+    times = t_arr
+    for i in range(H):
+        t_now = i * dt
+        times[i] = t_now
+        # Compute controls and sigma for each particle
+        for j, ctrl in enumerate(controllers):
+            x_curr = x_b[j, i]
+            # Use compute_control if available
+            try:
+                if hasattr(ctrl, "compute_control"):
+                    ret = ctrl.compute_control(x_curr, state_vars[j], histories[j])
+                    # ret may be namedtuple or tuple
+                    try:
+                        u_val = float(ret[0])
+                    except Exception:
+                        u_val = float(ret)
+                    # update state and history
+                    try:
+                        if len(ret) >= 2:
+                            state_vars[j] = ret[1]
+                        if len(ret) >= 3:
+                            histories[j] = ret[2]
+                    except Exception:
+                        pass
+                    # extract sigma if available
+                    sigma_val = 0.0
+                    if hasattr(ret, "sigma"):
+                        sigma_val = float(ret.sigma)
+                    elif hasattr(ret, "__len__") and len(ret) >= 4:
+                        sigma_val = float(ret[3])
+                else:
+                    u_val = float(ctrl(t_now, x_curr))
+                    sigma_val = 0.0
+            except Exception:
+                # On error computing control, treat as instability and stop
+                H = i
+                u_b = u_b[:, :i]
+                x_b = x_b[:, : i + 1]
+                sigma_b = sigma_b[:, :i]
+                times = times[: i + 1]
+                # Attach histories
+                for jj, c in enumerate(controllers):
+                    hist = histories[jj]
+                    if hist is not None:
+                        try:
+                            setattr(c, "_last_history", hist)
+                        except Exception:
+                            pass
+                if params_list is not None:
+                    return [(_np.copy(times), _np.copy(x_b), _np.copy(u_b), _np.copy(sigma_b)) for _ in params_list]
+                return times, x_b, u_b, sigma_b
+            # Saturate and store
+            limit = u_limits[j]
+            if limit < _np.inf:
+                if u_val > limit:
+                    u_val = limit
+                elif u_val < -limit:
+                    u_val = -limit
+            u_b[j, i] = u_val
+            sigma_b[j, i] = sigma_val
+        # Step all particles forward using their dynamics model
+        early_stop = False
+        for j, ctrl in enumerate(controllers):
+            dyn = getattr(ctrl, "dynamics_model", None)
+            if dyn is None:
+                # If controller lacks dynamics_model, fall back to global step
+                try:
+                    x_next = ctrl.step(x_b[j, i], u_b[j, i], dt)  # type: ignore[attr-defined]
+                except Exception:
+                    x_next = None
+            else:
+                try:
+                    x_next = dyn.step(x_b[j, i], u_b[j, i], dt)
+                except Exception:
+                    x_next = None
+            if x_next is None:
+                early_stop = True
+                break
+            x_next_arr = _np.asarray(x_next, dtype=float).reshape(-1)
+            if not _np.all(_np.isfinite(x_next_arr)):
+                early_stop = True
+                break
+            x_b[j, i + 1] = x_next_arr
+        if early_stop:
+            # truncate and exit
+            H = i
+            u_b = u_b[:, :i]
+            x_b = x_b[:, : i + 1]
+            sigma_b = sigma_b[:, :i]
+            times = times[: i + 1]
+            for jj, c in enumerate(controllers):
+                hist = histories[jj]
+                if hist is not None:
+                    try:
+                        setattr(c, "_last_history", hist)
+                    except Exception:
+                        pass
+            if params_list is not None:
+                return [(_np.copy(times), _np.copy(x_b), _np.copy(u_b), _np.copy(sigma_b)) for _ in params_list]
+            return times, x_b, u_b, sigma_b
+        # Early convergence check
+        if check_convergence and (i >= grace_steps):
+            max_sigma = _np.max(_np.abs(sigma_b[:, i]))
+            if max_sigma < conv_tol:
+                H = i + 1
+                u_b = u_b[:, : i + 1]
+                x_b = x_b[:, : i + 2]
+                sigma_b = sigma_b[:, : i + 1]
+                times = times[: i + 2]
+                # copy histories
+                for jj, c in enumerate(controllers):
+                    hist = histories[jj]
+                    if hist is not None:
+                        try:
+                            setattr(c, "_last_history", hist)
+                        except Exception:
+                            pass
+                if params_list is not None:
+                    return [(_np.copy(times), _np.copy(x_b), _np.copy(u_b), _np.copy(sigma_b)) for _ in params_list]
+                return times, x_b, u_b, sigma_b
+    # Finalise times
+    times[H] = H * dt
+    # attach histories on controllers
+    for jj, c in enumerate(controllers):
+        hist = histories[jj]
+        if hist is not None:
+            try:
+                setattr(c, "_last_history", hist)
+            except Exception:
+                pass
+    result = (times, x_b, u_b, sigma_b)
+    if params_list is None:
+        return result
+    # replicate results for each params entry
+    return [(_np.copy(times), _np.copy(x_b), _np.copy(u_b), _np.copy(sigma_b)) for _ in params_list]
