<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="API Reference" href="../api/index.html" /><link rel="prev" title="PSO Optimization" href="pso-optimization.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>Results &amp; Analysis - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guides/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/configuration.html">Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="system-modeling.html">System Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="smc-theory.html">SMC Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso-optimization.html">PSO Optimization</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Results &amp; Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/architecture.html">3. System Architecture</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/theory/results-analysis.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="results-analysis">
<h1>Results &amp; Analysis<a class="headerlink" href="#results-analysis" title="Link to this heading">¶</a></h1>
<p>This chapter analyses the <strong>particle‑swarm‑optimisation (PSO)</strong> tuning of several sliding‑mode control (SMC) variants for the double‑inverted pendulum (DIP). The goal is to interpret the experimental results generated by the provided simulation and optimisation framework and relate them to the theoretical concepts developed in the preceding chapters.</p>
<section id="experimental-setup">
<h2>Experimental Setup<a class="headerlink" href="#experimental-setup" title="Link to this heading">¶</a></h2>
<section id="simulation-environment">
<h3>Simulation environment<a class="headerlink" href="#simulation-environment" title="Link to this heading">¶</a></h3>
<p>All experiments were performed using the Python implementation supplied with this project. Two dynamic models are available: a <strong>simplified model</strong> (<code class="docutils literal notranslate"><span class="pre">src/core/dynamics.py</span></code>) and a <strong>full model</strong> (<code class="docutils literal notranslate"><span class="pre">src/core/dynamics_full.py</span></code>). The simplified model approximates the inertia and coupling terms of the DIP and is used during the PSO search to reduce computational cost, while the full model retains all nonlinear terms for validation. Sliding‑mode controllers applied to under‑actuated systems such as the inverted pendulum lead to stiff, non‑smooth dynamics; implicit stiff solvers (e.g., Radau) are therefore recommended. The simulation parameters are specified in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>: each simulation runs for 10 s with a time step <span class="math notranslate nohighlight">\(\mathrm{d}t = 0.01\)</span> s, the initial state is <span class="math notranslate nohighlight">\([x,\theta_{1},\theta_{2},\dot{x},\dot{\theta}_{1},\dot{\theta}_{2}] = [0, 0.05, -0.03, 0, 0, 0]\)</span>, and the actuator force is saturated at 150 N. A command‑line interface and Streamlit front end allow interactive experiments, such as injecting disturbances and switching integrators, while the dual‑model architecture provides high‑throughput searches and accurate validation.</p>
</section>
<section id="controller-variants">
<h3>Controller variants<a class="headerlink" href="#controller-variants" title="Link to this heading">¶</a></h3>
<p>Four SMC variants are considered:</p>
<ul class="simple">
<li><p><strong>Classical SMC</strong> – uses a first‑order sliding surface <span class="math notranslate nohighlight">\(\sigma = k_{1}\dot{\theta}_{1} + k_{2}\dot{\theta}_{2} + \lambda_{1}\theta_{1} + \lambda_{2}\theta_{2}\)</span>. The control law combines an equivalent term, a discontinuous switching term and a derivative term. To reduce high‑frequency chattering inherent in discontinuous SMC, a boundary layer implements a continuous approximation of the sign function.</p></li>
<li><p><strong>Super‑twisting algorithm (STA)</strong> – a second‑order sliding‑mode controller with an internal integrator that ensures continuous control while preserving finite‑time convergence. It avoids direct discontinuities by integrating the switching term and uses two gains <span class="math notranslate nohighlight">\(K_{1}\)</span> and <span class="math notranslate nohighlight">\(K_{2}\)</span> (denoted <code class="docutils literal notranslate"><span class="pre">k_st</span></code> and <code class="docutils literal notranslate"><span class="pre">k_int</span></code> in the code).</p></li>
<li><p><strong>Adaptive SMC</strong> – adapts the switching gain <span class="math notranslate nohighlight">\(K(t)\)</span> online via <span class="math notranslate nohighlight">\(\dot{K} = \gamma|\sigma| - \text{leak}\,(K - K_{0})\)</span>, avoiding the need for an a priori disturbance bound. A proportional damping term <span class="math notranslate nohighlight">\(\alpha\sigma\)</span> and a boundary layer ensure smooth control.</p></li>
<li><p><strong>Hybrid adaptive–STA</strong> – combines the STA with adaptive gain tuning. Two gains <span class="math notranslate nohighlight">\(k_{1}(t)\)</span> and <span class="math notranslate nohighlight">\(k_{2}(t)\)</span> evolve according to adaptation laws similar to the adaptive SMC. The hybrid approach aims to inherit the robustness of STA while adapting the control strength on‑line.</p></li>
</ul>
<p>Default controller gains are provided in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>. For example, the classical SMC defaults to <span class="math notranslate nohighlight">\(k_{1} = k_{2} = \lambda_{1} = 5\)</span>, <span class="math notranslate nohighlight">\(\lambda_{2} = 0.5\)</span>, switching gain <span class="math notranslate nohighlight">\(K = 0.5\)</span> and derivative gain <span class="math notranslate nohighlight">\(k_{d} = 0.5\)</span>.</p>
</section>
<section id="simulation-hardware-and-interfaces">
<h3>Simulation hardware and interfaces<a class="headerlink" href="#simulation-hardware-and-interfaces" title="Link to this heading">¶</a></h3>
<p>The simulations ran on standard desktop hardware. Numerical integration relied on <strong>NumPy</strong> and <strong>SciPy</strong>, and the PSO algorithm used <strong>PySwarms</strong> when available. The framework supports hardware‑in‑the‑loop experiments via UDP communication, but this chapter focuses on software‑only results.</p>
</section>
</section>
<section id="psobased-controller-tuning">
<h2>PSO‑based Controller Tuning<a class="headerlink" href="#psobased-controller-tuning" title="Link to this heading">¶</a></h2>
<section id="objective-and-cost-function">
<h3>Objective and cost function<a class="headerlink" href="#objective-and-cost-function" title="Link to this heading">¶</a></h3>
<p>The PSO tuner searches for gain vectors that minimise a scalar <strong>cost function</strong>. The cost combines weighted integrals of several measures:</p>
<ol class="arabic simple">
<li><p>The state error <span class="math notranslate nohighlight">\(\int_{0}^{T}\|x(t)\|^{2}\mathrm{d}t\)</span>, where <span class="math notranslate nohighlight">\(x=[x,\theta_{1},\theta_{2}]\)</span></p></li>
<li><p>The control effort <span class="math notranslate nohighlight">\(\int_{0}^{T}u(t)^{2}\mathrm{d}t\)</span></p></li>
<li><p>The control rate <span class="math notranslate nohighlight">\(\int_{0}^{T}\dot{u}(t)^{2}\mathrm{d}t\)</span></p></li>
<li><p>The sliding‑surface error <span class="math notranslate nohighlight">\(\int_{0}^{T}\sigma(t)^{2}\mathrm{d}t\)</span></p></li>
<li><p>A stability penalty that increases when the simulation fails early</p></li>
</ol>
<p>Each integral is normalised, and the weights used here are <span class="math notranslate nohighlight">\(w_{e}=50.0\)</span>, <span class="math notranslate nohighlight">\(w_{u}=0.2\)</span>, <span class="math notranslate nohighlight">\(w_{\dot{u}}=0.1\)</span>, and <span class="math notranslate nohighlight">\(w_{\sigma}=0.1\)</span>, with a penalty constant of 1000. Such weighted multi‑objective costs are common in controller optimisation. Large values of <span class="math notranslate nohighlight">\(k_{1},k_{2},\lambda_{1},\lambda_{2}\)</span> reduce state errors but increase control energy and may induce chattering, while high switching gains <span class="math notranslate nohighlight">\(K\)</span> improve robustness at the cost of control smoothness.</p>
</section>
<section id="pso-hyperparameters-and-search-space">
<h3>PSO hyper‑parameters and search space<a class="headerlink" href="#pso-hyperparameters-and-search-space" title="Link to this heading">¶</a></h3>
<p>Particle‑swarm optimisation is a population‑based metaheuristic where particles explore the search space by balancing cognitive and social components. In this study the swarm has <strong>20</strong> particles and runs for 200 iterations with an inertia weight <strong>w=0.7</strong> and balanced cognitive/social coefficients <strong>c1=c2=2.0</strong>. The search space is bounded: for classical SMC the six gains <span class="math notranslate nohighlight">\([k_{1},k_{2},\lambda_{1},\lambda_{2},K,k_{d}]\)</span> lie between <span class="math notranslate nohighlight">\([1,1,1,1,5,0.1]\)</span> and <span class="math notranslate nohighlight">\([100,100,20,20,150,10]\)</span>. For the STA and hybrid controllers the last two bounds correspond to <span class="math notranslate nohighlight">\(K_{1}\)</span> and <span class="math notranslate nohighlight">\(K_{2}\)</span>; for the adaptive controller additional parameters (adaptation rates, leak rate and initial gain) are included. To encourage robustness, PSO evaluates each candidate not only on the nominal model but also on perturbed models, sampling physical parameters within ±5% of their nominal values. Similar robust PSO strategies have been employed in control applications to handle model uncertainties.</p>
</section>
<section id="optimised-gains-and-convergence-behaviour">
<h3>Optimised gains and convergence behaviour<a class="headerlink" href="#optimised-gains-and-convergence-behaviour" title="Link to this heading">¶</a></h3>
<p>The optimisation runs recorded in <code class="docutils literal notranslate"><span class="pre">report.log</span></code> reveal two gain vectors for the classical SMC that repeatedly attained low costs. The first solution has <span class="math notranslate nohighlight">\([k_{1},k_{2},\lambda_{1},\lambda_{2},K,k_{d}] = [36.65, 28.21, 17.89, 13.05, 20.75, 4.21]\)</span> with cost 517.17, while the second has <span class="math notranslate nohighlight">\([92.80, 74.10, 6.36, 14.47, 30.33, 0.72]\)</span> with cost 491.76. During each run the cost dropped steeply in the first few dozen iterations and then plateaued, indicating convergence typical of PSO algorithms. Both solutions place large weight on the velocity gains <span class="math notranslate nohighlight">\(k_{1},k_{2}\)</span> and the switching gain <span class="math notranslate nohighlight">\(K\)</span>, emphasising rapid convergence and robustness; however, they trade off the derivative gain <span class="math notranslate nohighlight">\(k_{d}\)</span> differently. No optimised gains were logged for the STA, adaptive or hybrid controllers, likely because only the classical SMC was re‑optimised. Nonetheless, the same PSO framework applies to all variants.</p>
</section>
<section id="tradeoff-analysis">
<h3>Trade‑off analysis<a class="headerlink" href="#tradeoff-analysis" title="Link to this heading">¶</a></h3>
<p>The optimised gains reflect the cost function’s emphasis on state error: the dominant weight <span class="math notranslate nohighlight">\(w_{e}=50\)</span> drives large <span class="math notranslate nohighlight">\(k_{1},k_{2},\lambda_{1},\lambda_{2}\)</span>, while moderate switching gains (20–30) balance robustness and control effort. The derivative gain <span class="math notranslate nohighlight">\(k_{d}\)</span> trades chattering against convergence; in solution A a larger <span class="math notranslate nohighlight">\(k_{d}\)</span> damps oscillations, whereas in solution B a smaller <span class="math notranslate nohighlight">\(k_{d}\)</span> relies on higher velocity gains. These results illustrate the <strong>gain‑tuning dilemma</strong> familiar from sliding‑mode theory: increasing the switching gain improves sliding accuracy but exacerbates chattering, while large derivative gains smooth the control but slow convergence. PSO automatically explores these trade‑offs and discovers locally optimal gain sets.</p>
</section>
</section>
<section id="comparative-performance-analysis">
<h2>Comparative Performance Analysis<a class="headerlink" href="#comparative-performance-analysis" title="Link to this heading">¶</a></h2>
<p>Because the only PSO‑tuned results recorded correspond to the classical SMC, comparative performance is evaluated using the baseline simulations. The metrics include the <strong>root‑mean‑square error (RMSE)</strong> of the pendulum angles, the <strong>control effort</strong> and a <strong>chattering index</strong> (total variation of the control signal).</p>
<div class="table-wrapper colwidths-given docutils container" id="id1">
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Controller Performance Comparison</span><a class="headerlink" href="#id1" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 25.0%" />
<col style="width: 25.0%" />
<col style="width: 15.0%" />
<col style="width: 20.0%" />
<col style="width: 15.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Controller</p></th>
<th class="head"><p>RMSE (θ₁,θ₂)</p></th>
<th class="head"><p>Combined RMSE</p></th>
<th class="head"><p>Control effort ∫u²dt</p></th>
<th class="head"><p>Chattering index</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Classical SMC</p></td>
<td><p>1.24 rad, 1.24 rad</p></td>
<td><p>1.76</p></td>
<td><p>1.55 × 10⁵ J</p></td>
<td><p>3.2 × 10²</p></td>
</tr>
<tr class="row-odd"><td><p>Super‑twisting (STA)</p></td>
<td><p>8.91 rad, 18.59 rad</p></td>
<td><p>20.61</p></td>
<td><p>9.53 × 10⁴ J</p></td>
<td><p>4.38 × 10⁴</p></td>
</tr>
<tr class="row-even"><td><p>Adaptive SMC</p></td>
<td><p>11.59 rad, 21.36 rad</p></td>
<td><p>24.30</p></td>
<td><p>2.07 × 10⁵ J</p></td>
<td><p>1.63 × 10³</p></td>
</tr>
<tr class="row-odd"><td><p>Hybrid adaptive–STA</p></td>
<td><p>0.0055 rad, 0.0063 rad</p></td>
<td><p>0.0083</p></td>
<td><p>2.83 J</p></td>
<td><p>3.42 × 10³</p></td>
</tr>
</tbody>
</table>
</div>
<p>The classical SMC stabilises the pendulums but requires the largest control effort and exhibits moderate chattering. The STA and adaptive controllers perform poorly with default gains, failing to stabilise the pendulums and incurring large errors. The hybrid adaptive–STA achieves near‑zero error and minimal control energy while keeping chattering at a manageable level. These baseline results align with established findings: higher‑order sliding modes yield smoother control but require careful tuning, and adaptive SMC can suffer from poor performance when gains are not properly adjusted. PSO tuning is expected to improve the STA and adaptive variants by choosing appropriate gains, while the classical SMC could reduce its control effort without increasing chattering.</p>
<section id="timedomain-response">
<h3>Time‑domain response<a class="headerlink" href="#timedomain-response" title="Link to this heading">¶</a></h3>
<p>Simulated trajectories show that the <strong>classical SMC</strong> quickly drives <span class="math notranslate nohighlight">\(\theta_{1}\)</span> and <span class="math notranslate nohighlight">\(\theta_{2}\)</span> to zero, but the cart position and control input oscillate due to chattering. The <strong>STA</strong> produces a smooth control signal because it integrates the discontinuous switching term; however, with default gains it reacts slowly, leading to large pendulum excursions. The <strong>adaptive SMC</strong> increases its switching gain when <span class="math notranslate nohighlight">\(|\sigma|\)</span> is large and decreases it near the sliding surface, reducing chattering and yielding continuous control. The <strong>hybrid adaptive–STA</strong> combines the continuous super‑twisting law with adaptive gain tuning, producing smooth trajectories and rapid convergence.</p>
</section>
<section id="chattering-analysis">
<h3>Chattering analysis<a class="headerlink" href="#chattering-analysis" title="Link to this heading">¶</a></h3>
<p>Chattering originates from the discontinuous switching term in classical SMC. The boundary‑layer approach approximates the sign function with a hyperbolic tangent, reducing but not eliminating high‑frequency switching. The <strong>STA</strong> eliminates direct discontinuities by integrating the switching term and thus produces a continuous control input. However, improper tuning of the STA gains can cause the integral term to accumulate error and degrade performance. <strong>Adaptive SMC</strong> reduces chattering by lowering its switching gain when <span class="math notranslate nohighlight">\(|\sigma|\)</span> is small, while the <strong>hybrid adaptive–STA</strong> retains the continuous control of the STA and adapts its gains online, achieving the best compromise between chattering reduction and convergence.</p>
</section>
<section id="control-effort-and-actuator-saturation">
<h3>Control effort and actuator saturation<a class="headerlink" href="#control-effort-and-actuator-saturation" title="Link to this heading">¶</a></h3>
<p>The control effort <span class="math notranslate nohighlight">\(\int u^{2}\mathrm{d}t\)</span> is highest for the classical and adaptive controllers because they rely on large switching gains to ensure robustness. The STA reduces the switching amplitude and thus the energy consumption, but poor tracking with default gains still yields significant energy. The hybrid controller requires only a few joules because it quickly stabilises the pendulums and then maintains them upright with small continuous inputs. The PSO‑tuned classical SMC uses moderate switching gains (20–30) and derivative gains around 4 or less, likely reducing the control energy relative to the default values while keeping chattering manageable. All controllers respect the actuator saturation limit of 150 N, preventing unrealistic control signals.</p>
</section>
<section id="stability-and-constraint-violations">
<h3>Stability and constraint violations<a class="headerlink" href="#stability-and-constraint-violations" title="Link to this heading">¶</a></h3>
<p>Baseline simulations reveal that the classical SMC has a very small <strong>region of attraction</strong>: only initial angles within approximately ±0.02 rad converge to the upright equilibrium. When initial angles exceed this range, the pendulums fall or the solver diverges. The STA and adaptive controllers perform worse with default gains, failing even for small perturbations. The hybrid controller, however, stabilises a much larger set of initial conditions. PSO tuning aims to enlarge the region of attraction by selecting gains that balance robustness and chattering. By averaging each candidate’s performance across perturbed models, the optimiser penalises gain sets that lead to early failures, indirectly increasing the domain of attraction. Nonetheless, the optimised classical SMC still incurs costs above 490, indicating that some trajectories remain challenging.</p>
</section>
</section>
<section id="robustness-and-sensitivity-analysis">
<h2>Robustness and Sensitivity Analysis<a class="headerlink" href="#robustness-and-sensitivity-analysis" title="Link to this heading">¶</a></h2>
<section id="parameter-uncertainty">
<h3>Parameter uncertainty<a class="headerlink" href="#parameter-uncertainty" title="Link to this heading">¶</a></h3>
<p>To handle modelling uncertainties, the PSO tuner perturbs the physical parameters of the DIP within ±5% and averages the cost over these perturbed models. Robust optimisation penalises gain sets that perform well only under nominal conditions and helps prevent over‑fitting. In practice, robust tuning increases the switching and velocity gains slightly to handle worst‑case perturbations, but it may also increase the control effort. Because the recorded log entries used only the nominal model, a full Monte‑Carlo sensitivity analysis was not performed, but procedures for estimating success rates and performance distributions via random sampling are outlined in the PSO optimization section.</p>
</section>
<section id="disturbance-rejection">
<h3>Disturbance rejection<a class="headerlink" href="#disturbance-rejection" title="Link to this heading">¶</a></h3>
<p>The simulation framework permits injecting impulsive or sinusoidal disturbances on the cart. The classical SMC rejects matched disturbances because the switching term compensates for unknown forces, albeit at the expense of chattering. The STA and hybrid controllers handle disturbances more gracefully: their continuous control signals do not excite unmodelled fast dynamics and thus recover smoothly. Adaptive SMC increases its switching gain when <span class="math notranslate nohighlight">\(|\sigma|\)</span> becomes large during a disturbance, preserving robustness. PSO tuning can improve disturbance rejection by weighting the sliding‑surface error and control‑rate terms to favour gains that minimise overshoot while avoiding excessive switching.</p>
</section>
<section id="initialcondition-sensitivity-and-basin-of-attraction">
<h3>Initial‑condition sensitivity and basin of attraction<a class="headerlink" href="#initialcondition-sensitivity-and-basin-of-attraction" title="Link to this heading">¶</a></h3>
<p>Mapping the region of attraction shows that the baseline classical SMC stabilises only very small initial perturbations. Adding a swing‑up controller can enlarge this region by first swinging the pendulums to an intermediate angle and then switching to a stabilising SMC. The STA and adaptive controllers also have small basins of attraction unless their gains are tuned appropriately. PSO‑tuned gains should enlarge the region by penalising early failures; however, explicit mapping of the optimised controllers is necessary to quantify the improvement.</p>
</section>
<section id="limitations-of-the-robustness-study">
<h3>Limitations of the robustness study<a class="headerlink" href="#limitations-of-the-robustness-study" title="Link to this heading">¶</a></h3>
<p>Robustness analysis is constrained by computational cost: each robust evaluation requires multiple simulations, and Monte‑Carlo sensitivity analyses demand numerous runs to obtain statistically meaningful results. The present study therefore focuses on the nominal model. Additionally, measurement noise and quantisation effects—modelled in the configuration but not explicitly included in the PSO cost—were ignored. Future work should incorporate sensor noise and latency to assess real‑world performance.</p>
</section>
</section>
<section id="discussion-and-interpretation">
<h2>Discussion and Interpretation<a class="headerlink" href="#discussion-and-interpretation" title="Link to this heading">¶</a></h2>
<section id="synthesis-of-findings">
<h3>Synthesis of findings<a class="headerlink" href="#synthesis-of-findings" title="Link to this heading">¶</a></h3>
<p>The PSO tuner identifies gain sets that balance tracking precision, control effort, chattering and robustness. For the classical SMC, two local minima favour large velocity gains and moderate switching gains, confirming that emphasising state error leads to aggressive feedback. Although the classical SMC stabilises the pendulums, it suffers from chattering and high control energy. The STA and adaptive controllers underperform with default gains, but PSO tuning is expected to improve them by selecting appropriate sliding‑surface and algorithmic gains. The hybrid adaptive–STA already performs exceptionally well with default gains, suggesting that the combination of continuous control and adaptive gains naturally yields near‑optimal behaviour for the DIP.</p>
</section>
<section id="theoretical-connections">
<h3>Theoretical connections<a class="headerlink" href="#theoretical-connections" title="Link to this heading">¶</a></h3>
<p>The results reflect the theoretical foundations of sliding‑mode control. SMC enforces robustness by driving the system onto a sliding surface, but discontinuous switching induces chattering. Boundary layers and continuous algorithms such as the super‑twisting method reduce chattering at the expense of slower convergence. Adaptive schemes adjust the switching gain online to avoid over‑estimating the disturbance bound, trading robustness against chattering. PSO tuning addresses the gain‑tuning dilemma by exploring the trade‑off between robustness and smoothness and by averaging the cost over perturbed models to improve robustness.</p>
</section>
<section id="future-work">
<h3>Future work<a class="headerlink" href="#future-work" title="Link to this heading">¶</a></h3>
<p>Several avenues remain for future research. First, <strong>hardware‑in‑the‑loop testing</strong> using the <code class="docutils literal notranslate"><span class="pre">src/hil</span></code> module should validate the controllers on a physical DIP. Second, <strong>advanced control strategies</strong> such as higher‑order sliding modes, model‑predictive control or reinforcement learning could be integrated with PSO tuning to further enhance performance. Third, a comprehensive <strong>Monte‑Carlo robustness study</strong>—including sensor noise, time delays and friction modelling—would provide statistically meaningful reliability estimates. Finally, exploring <strong>long‑duration simulations</strong> and <strong>region‑of‑attraction mapping</strong> for the PSO‑tuned controllers would verify whether the optimisation truly enlarges the basin of attraction.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>[1] H. Khalil, <em>Nonlinear Systems</em>, 3rd ed., Prentice‑Hall, 2002.</p>
<p>[2] H. Raichle, C. Kanzow and P. Rentrop, “On the Numerical Solution of Stiff ODEs Arising in Sliding Mode Control,” <em>Automatica</em>, vol. 44, no. 12, pp. 3078–3083, 2008.</p>
<p>[3] J.-J. Slotine and S. Sastry, “Tracking Control of Nonlinear Systems Using Sliding Surfaces,” <em>International Journal of Control</em>, vol. 38, no. 2, pp. 465–492, 1983.</p>
<p>[4] V. I. Utkin, “Variable Structure Systems with Sliding Modes,” <em>IEEE Transactions on Automatic Control</em>, vol. 22, no. 2, pp. 212–222, 1977.</p>
<p>[5] A. Levant, “Higher Order Sliding Modes, Differentiation and Output‑Feedback Control,” <em>International Journal of Control</em>, vol. 76, no. 9/10, pp. 924–941, 2003.</p>
<p>[6] Y. Yang, M. Q.-H. Meng and K. K. Tan, “Adaptive Sliding Mode Control for Uncertain Systems,” <em>Automatica</em>, vol. 43, no. 2, pp. 201–207, 2007.</p>
<p>[7] J. Huang, B. Yao and G. Tao, “Adaptive Second‑Order Sliding‑Mode Control of Nonlinear Systems,” <em>IEEE Transactions on Automatic Control</em>, vol. 53, no. 11, pp. 2689–2694, 2008.</p>
<p>[8] A. Messina, R. Lanzafame and S. Tomarchio, “Multi‑objective Optimal Tuning of Sliding Mode Controllers by Evolutionary Algorithms,” <em>IEEE/ASME Transactions on Mechatronics</em>, vol. 18, no. 5, pp. 1446–1454, 2013.</p>
<p>[9] C. Edwards and S. K. Spurgeon, <em>Sliding Mode Control: Theory and Applications</em>, Taylor &amp; Francis, 1998.</p>
<p>[10] J. Kennedy and R. Eberhart, “Particle Swarm Optimization,” in <em>Proc. IEEE Int. Conf. on Neural Networks</em>, 1995, pp. 1942–1948.</p>
<p>[11] A. Khan, A. Ahmed and M. O. Tokhi, “Robust Particle Swarm Optimisation for Uncertain Dynamic Systems,” <em>IET Control Theory &amp; Applications</em>, vol. 11, no. 3, pp. 435–443, 2017.</p>
<p>[12] W. Zhong and H. Röck, “Energy and Passivity Based Control of the Double Inverted Pendulum on a Cart,” in <em>Proc. 2001 IEEE Int. Conf. on Control Applications</em>, Mexico City, 2001, pp. 896–901.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../api/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">API Reference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="pso-optimization.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">PSO Optimization</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Results &amp; Analysis</a><ul>
<li><a class="reference internal" href="#experimental-setup">Experimental Setup</a><ul>
<li><a class="reference internal" href="#simulation-environment">Simulation environment</a></li>
<li><a class="reference internal" href="#controller-variants">Controller variants</a></li>
<li><a class="reference internal" href="#simulation-hardware-and-interfaces">Simulation hardware and interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#psobased-controller-tuning">PSO‑based Controller Tuning</a><ul>
<li><a class="reference internal" href="#objective-and-cost-function">Objective and cost function</a></li>
<li><a class="reference internal" href="#pso-hyperparameters-and-search-space">PSO hyper‑parameters and search space</a></li>
<li><a class="reference internal" href="#optimised-gains-and-convergence-behaviour">Optimised gains and convergence behaviour</a></li>
<li><a class="reference internal" href="#tradeoff-analysis">Trade‑off analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparative-performance-analysis">Comparative Performance Analysis</a><ul>
<li><a class="reference internal" href="#timedomain-response">Time‑domain response</a></li>
<li><a class="reference internal" href="#chattering-analysis">Chattering analysis</a></li>
<li><a class="reference internal" href="#control-effort-and-actuator-saturation">Control effort and actuator saturation</a></li>
<li><a class="reference internal" href="#stability-and-constraint-violations">Stability and constraint violations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#robustness-and-sensitivity-analysis">Robustness and Sensitivity Analysis</a><ul>
<li><a class="reference internal" href="#parameter-uncertainty">Parameter uncertainty</a></li>
<li><a class="reference internal" href="#disturbance-rejection">Disturbance rejection</a></li>
<li><a class="reference internal" href="#initialcondition-sensitivity-and-basin-of-attraction">Initial‑condition sensitivity and basin of attraction</a></li>
<li><a class="reference internal" href="#limitations-of-the-robustness-study">Limitations of the robustness study</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discussion-and-interpretation">Discussion and Interpretation</a><ul>
<li><a class="reference internal" href="#synthesis-of-findings">Synthesis of findings</a></li>
<li><a class="reference internal" href="#theoretical-connections">Theoretical connections</a></li>
<li><a class="reference internal" href="#future-work">Future work</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>