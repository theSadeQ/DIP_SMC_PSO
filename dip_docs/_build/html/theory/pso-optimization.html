<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Results &amp; Analysis" href="results-analysis.html" /><link rel="prev" title="SMC Theory" href="smc-theory.html" />

    <!-- Generated with Sphinx 8.2.3 and Furo 2024.08.06 -->
        <title>PSO Optimization - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../guides/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/configuration.html">Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Theory</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="system-modeling.html">System Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="smc-theory.html">SMC Theory</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="results-analysis.html">Results &amp; Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../development/contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/architecture.html">3. System Architecture</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/theory/pso-optimization.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="pso-optimization">
<h1>PSO Optimization<a class="headerlink" href="#pso-optimization" title="Link to this heading">¶</a></h1>
<p>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</p>
<section id="introduction-and-background">
<h2>Introduction and Background<a class="headerlink" href="#introduction-and-background" title="Link to this heading">¶</a></h2>
<p>The double‑inverted pendulum (DIP) consists of two slender rigid links mounted on a cart that can move along a horizontal rail. Each link is hinged at its base and is inherently unstable in the upright position, so even small disturbances will cause it to fall. The control objective is to keep the cart at a desired position (usually the origin) while balancing both pendulums upright. The project implements a <strong>classical sliding‑mode controller (SMC)</strong>, a robust control strategy that forces the system state onto a user‑defined switching surface and maintains it there despite matched uncertainties and disturbances.</p>
<p>The controller defines a <strong>sliding surface</strong>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sigma = \lambda_{1}\theta_{1} + \lambda_{2}\theta_{2} + k_{1}\dot{\theta}_{1} + k_{2}\dot{\theta}_{2}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\theta_{1}\)</span> and <span class="math notranslate nohighlight">\(\theta_{2}\)</span> are the pendulum angles and <span class="math notranslate nohighlight">\(\dot{\theta}_{1}\)</span>, <span class="math notranslate nohighlight">\(\dot{\theta}_{2}\)</span> are their rates. When <span class="math notranslate nohighlight">\(\sigma = 0\)</span> the system behaves like a reduced‑order linear system that drives the pendulum angles and velocities to zero. As in standard SMC design the control law combines an <strong>equivalent control</strong> term (obtained by canceling the nominal dynamics) and a <strong>robust control</strong> term that forces the system to reach and stay on the sliding surface:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[u = u_{\mathrm{eq}} - K\mathrm{sat}\left(\frac{\sigma}{\epsilon}\right) - k_{\mathrm{d}}\sigma\]</div>
</div>
<p>Here <span class="math notranslate nohighlight">\(\mathrm{sat}(\cdot)\)</span> is a continuous approximation of the discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}\)</span> function. Classical SMC uses a discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}(\sigma)\)</span> which produces high‑frequency chattering. A common remedy is to introduce a boundary layer and replace <span class="math notranslate nohighlight">\(\mathrm{sign}(\sigma)\)</span> with a smooth saturation function such as the hyperbolic tangent. In the provided code the <code class="docutils literal notranslate"><span class="pre">saturate</span></code> utility chooses between a hyperbolic tangent and a linear saturation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">saturate</span><span class="p">(</span><span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tanh&quot;</span><span class="p">):</span>
    <span class="c1"># Continuous approximation of sign(sigma) within a boundary layer</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;tanh&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span> defines a <strong>boundary layer</strong> that mitigates chattering by smoothing the switching action. As <span class="math notranslate nohighlight">\(\epsilon \rightarrow 0\)</span> the saturation approximates the discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}\)</span> function, whereas increasing <span class="math notranslate nohighlight">\(\epsilon\)</span> yields smoother control at the expense of convergence speed. The baseline controller sets <span class="math notranslate nohighlight">\(\epsilon = 0.02\)</span> and uses the hyperbolic tangent method, consistent with improved power reaching laws that employ smooth saturation functions to reduce chattering.</p>
</section>
<section id="simulation-framework-challenges">
<h2>Simulation Framework Challenges<a class="headerlink" href="#simulation-framework-challenges" title="Link to this heading">¶</a></h2>
<section id="numerical-stiffness-from-discontinuous-control">
<h3>Numerical stiffness from discontinuous control<a class="headerlink" href="#numerical-stiffness-from-discontinuous-control" title="Link to this heading">¶</a></h3>
<p>Sliding‑mode control uses high‑gain feedback and discontinuous switching to force states onto the sliding surface. In practice the boundary layer smooths the discontinuity, but for small <span class="math notranslate nohighlight">\(\epsilon\)</span> the right‑hand side still exhibits very steep gradients. The dynamics of the DIP combine slow cart motion with fast pendulum oscillations and fast switching in the control law. This results in <strong>stiff differential equations</strong>: the solver must resolve both slow and very fast dynamics simultaneously. Explicit fixed‑step integrators (such as Euler or fourth‑order Runge–Kutta) cannot safely integrate such systems because large steps lead to oscillations or divergence, whereas very small steps yield high computational cost. Implicit stiff solvers are therefore preferred for systems with multiple time scales.</p>
</section>
<section id="limitations-of-the-fixedstep-simulation">
<h3>Limitations of the fixed–step simulation<a class="headerlink" href="#limitations-of-the-fixedstep-simulation" title="Link to this heading">¶</a></h3>
<p>The original simulation loop employed a fixed time step <span class="math notranslate nohighlight">\(dt = 0.01\,\text{s}\)</span> and integrated the dynamics using a hand‑coded RK4 method in <code class="docutils literal notranslate"><span class="pre">dynamics.DoubleInvertedPendulum.step</span></code>. With the baseline SMC gains the system was highly unstable for anything other than tiny initial angles. Even when the step was reduced to 0.001 s, the integration frequently diverged because the solver could not adapt to the stiff dynamics near the switching surface. Moreover, because the control law computes a model‑based equivalent control <code class="docutils literal notranslate"><span class="pre">u_eq</span></code> by inverting the inertia matrix, numerical singularities or large condition numbers can appear during integration. The controller code detects near‑singular matrices and returns zero to preserve stability, but the resulting abrupt change in torque further stiffens the problem.</p>
</section>
<section id="need-for-adaptive-stiff-integrators">
<h3>Need for adaptive stiff integrators<a class="headerlink" href="#need-for-adaptive-stiff-integrators" title="Link to this heading">¶</a></h3>
<p>The <strong>SciPy</strong> routine <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> provides a suite of adaptive methods that adjust the step size to meet prescribed error tolerances. Explicit methods like <code class="docutils literal notranslate"><span class="pre">RK45</span></code> are efficient for non‑stiff systems, while implicit methods such as the <strong>Backward Differentiation Formula (BDF)</strong> or <strong>Radau</strong> are recommended for stiff problems. Implicit BDF methods suffer from an order barrier—orders above five are unstable—whereas Radau IIA schemes are A‑stable and L‑stable at arbitrary order, providing large stability regions for stiff systems. For our system, preliminary experiments showed that <code class="docutils literal notranslate"><span class="pre">RK45</span></code> took extremely small steps and failed to converge, whereas <code class="docutils literal notranslate"><span class="pre">Radau</span></code> handled the stiff sliding dynamics more robustly. A robust simulation loop therefore employs <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> with an adaptive stiff integrator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dip_ode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">dyn</span><span class="p">):</span>
    <span class="c1"># x = [x, theta1, theta2, xdot, dtheta1, dtheta2]</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">compute_control</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
    <span class="n">dxdt</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dxdt</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">dip_ode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">),</span>
    <span class="n">t_span</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span>
    <span class="n">y0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">max_step</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The solver automatically reduces the step size near steep gradients and increases it when the dynamics slow down, yielding accurate trajectories with fewer function evaluations.</p>
</section>
</section>
<section id="proposed-enhancements-and-methodology">
<h2>Proposed Enhancements and Methodology<a class="headerlink" href="#proposed-enhancements-and-methodology" title="Link to this heading">¶</a></h2>
<section id="adaptive-integrators-and-event-handling">
<h3>Adaptive integrators and event handling<a class="headerlink" href="#adaptive-integrators-and-event-handling" title="Link to this heading">¶</a></h3>
<p>Switching to adaptive stiff solvers addresses the numerical instability observed with fixed‑step methods. <strong>Event functions</strong> can be added to <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> to halt integration if the pendulum angles exceed safe limits (e.g., <span class="math notranslate nohighlight">\(|\theta_{i}| &gt; \pi/2\)</span>). By terminating unstable simulations early we avoid wasting computational effort and can classify initial states as failures. The integrator parameters <span class="math notranslate nohighlight">\(\text{rtol} = 10^{-6}\)</span>, <span class="math notranslate nohighlight">\(\text{atol} = 10^{-8}\)</span> and <span class="math notranslate nohighlight">\(\text{max\_step} = 0.01\,\text{s}\)</span> were found to balance accuracy and speed in the stiff regime.</p>
</section>
<section id="chattering-mitigation-via-boundary-layer">
<h3>Chattering mitigation via boundary layer<a class="headerlink" href="#chattering-mitigation-via-boundary-layer" title="Link to this heading">¶</a></h3>
<p>The discontinuous <code class="docutils literal notranslate"><span class="pre">sign()</span></code> function in the baseline SMC produces high‑frequency chatter. Introducing a <strong>boundary layer</strong> smooths the switching term so that the control becomes:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[u_{\text{robust}} = - K\, \mathrm{sat}\left( \frac{\sigma}{\epsilon} \right) - k_{d}\sigma\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\mathrm{sat}\left( \frac{\sigma}{\epsilon} \right)\)</span> is either <span class="math notranslate nohighlight">\(\tanh(\sigma/\epsilon)\)</span> or <span class="math notranslate nohighlight">\(\text{clip}(\sigma/\epsilon, -1,1)\)</span>. The derivative term <span class="math notranslate nohighlight">\(- k_{d}\sigma\)</span> further damps sliding dynamics. Choosing <span class="math notranslate nohighlight">\(\epsilon\)</span> too small leads to chattering; increasing <span class="math notranslate nohighlight">\(\epsilon\)</span> reduces chattering but slows convergence. Simulation results show that <span class="math notranslate nohighlight">\(\epsilon = 0.02\)</span> provides a good compromise for the DIP. Adaptive boundary layers can also be implemented to widen <span class="math notranslate nohighlight">\(\epsilon\)</span> when <span class="math notranslate nohighlight">\(\sigma\)</span> is large and tighten it near the origin, as suggested in improved power‑reaching laws for sliding‑mode control.</p>
</section>
<section id="filtering-noisy-measurements">
<h3>Filtering noisy measurements<a class="headerlink" href="#filtering-noisy-measurements" title="Link to this heading">¶</a></h3>
<p>In practice sensors introduce noise that can drive the controller and cause chattering. Two complementary filters are proposed:</p>
<ol class="arabic">
<li><p><strong>Moving average filter.</strong> A simple moving average computes the unweighted mean of the last <span class="math notranslate nohighlight">\(k\)</span> samples. For a sequence <span class="math notranslate nohighlight">\(p_{1},p_{2},\ldots,p_{n}\)</span> the mean over the last <span class="math notranslate nohighlight">\(k\)</span> samples is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\text{SMA}_{k} = \frac{p_{n - k + 1} + p_{n - k + 2} + \cdots + p_{n}}{k} = \frac{1}{k}\sum_{i = n - k + 1}^{n}p_{i}\]</div>
</div>
<p>Smoothing filters such as the moving average reduce high‑frequency noise by averaging neighbouring points. In functional near‑infrared spectroscopy data processing, the moving average filter replaces the value at each point with the average of neighbouring data points, thereby reducing high‑frequency fluctuations. Applying an SMA to measured angles smooths high‑frequency noise but introduces a delay proportional to <span class="math notranslate nohighlight">\(k/2\)</span>. Choosing <span class="math notranslate nohighlight">\(k\)</span> between 3 and 7 samples at a <strong>100 Hz</strong> (10 ms) sampling rate offers a good compromise between smoothing and latency.</p>
</li>
<li><p><strong>Kalman filter.</strong> The Kalman filter models the system in discrete state–space form <span class="math notranslate nohighlight">\(x_{k + 1} = Fx_{k} + Bu_{k} + w_{k}\)</span> and <span class="math notranslate nohighlight">\(y_{k} = Hx_{k} + v_{k}\)</span>. It recursively performs a <strong>prediction</strong> and <strong>update</strong> step. The prediction step computes the a‑priori state and covariance:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\hat{x}_{k|k - 1} = F_{k}\hat{x}_{k - 1|k - 1} + B_{k}u_{k}, \quad P_{k|k - 1} = F_{k}P_{k - 1|k - 1}F_{k}^{\mathsf{T}} + Q_{k}\]</div>
</div>
<p>and the update step incorporates the measurement <span class="math notranslate nohighlight">\(z_{k}\)</span> using the Kalman gain <span class="math notranslate nohighlight">\(K_{k}\)</span>:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[K_{k} = P_{k|k - 1}H_{k}^{\mathsf{T}}S_{k}^{- 1}, \quad \hat{x}_{k|k} = \hat{x}_{k|k - 1} + K_{k}\left( z_{k} - H_{k}\hat{x}_{k|k - 1} \right), \quad P_{k|k} = \left( I - K_{k}H_{k} \right)P_{k|k - 1}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(S_{k} = H_{k}P_{k|k - 1}H_{k}^{\mathsf{T}} + R_{k}\)</span> is the innovation covariance. Under the assumption that the process and measurement noise are independent, white and Gaussian, the Kalman filter provides an optimal linear estimator.</p>
</li>
</ol>
</section>
<section id="improved-pso-cost-function">
<h3>Improved PSO cost function<a class="headerlink" href="#improved-pso-cost-function" title="Link to this heading">¶</a></h3>
<p>The particle swarm optimisation (PSO) routine tunes the six gains <span class="math notranslate nohighlight">\([k_{1},k_{2},\lambda_{1},\lambda_{2},K,k_{d}]\)</span> to minimise a cost function. PSO is a population‑based metaheuristic inspired by the collective behaviour of bird flocks: each particle (candidate solution) remembers its best previous position and is attracted toward the best position found by the entire swarm. Velocities are updated using cognitive and social weights with random coefficients, and positions are updated accordingly. Because the algorithm does not rely on gradients it can be applied to a wide range of optimisation problems and has spawned numerous variations.</p>
<p>The cost is computed from the simulated trajectory using weighted integrals:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[J = w_{e} \cdot \frac{1}{N_{e}}\int_{0}^{T} \|x(t)\|^{2}dt + w_{u} \cdot \frac{1}{N_{u}}\int_{0}^{T}u(t)^{2}dt + w_{\dot{u}} \cdot \frac{1}{N_{\dot{u}}}\int_{0}^{T}\dot{u}(t)^{2}dt + w_{\sigma} \cdot \frac{1}{N_{\sigma}}\int_{0}^{T}\sigma(t)^{2}dt + w_{\text{stab}} \cdot \frac{T - t_{\text{fail}}}{T} \cdot P_{\text{penalty}}\]</div>
</div>
<p>The first term (state error) penalises deviations of cart position and pendulum angles from zero. The second and third terms penalise large control efforts and large control slews, reflecting actuator limitations. The fourth term penalises large sliding surface values, encouraging the system to converge quickly onto the sliding manifold. The last term applies a penalty if the simulation fails before the full duration, with the penalty proportional to how early the failure occurs. In the provided configuration the weights are <span class="math notranslate nohighlight">\(w_{e} = 50\)</span>, <span class="math notranslate nohighlight">\(w_{u} = 0.2\)</span>, <span class="math notranslate nohighlight">\(w_{\dot{u}} = 0.1\)</span>, <span class="math notranslate nohighlight">\(w_{\sigma} = 0.1\)</span> and the penalty constant <span class="math notranslate nohighlight">\(P_{\text{penalty}} = 1000\)</span>. Each integral is normalised by an empirically chosen constant <span class="math notranslate nohighlight">\(N_{e},N_{u},N_{\dot{u}},N_{\sigma}\)</span> to make the contributions comparable.</p>
</section>
<section id="regionofattraction-mapping">
<h3>Region‑of‑attraction mapping<a class="headerlink" href="#regionofattraction-mapping" title="Link to this heading">¶</a></h3>
<p>To quantify the controller’s basin of attraction we systematically sample initial conditions. For each pair of initial angles <span class="math notranslate nohighlight">\(\theta_{1}(0),\theta_{2}(0)\)</span> (with zero velocities and cart position) we integrate the system until the final time or until either pendulum angle exceeds <span class="math notranslate nohighlight">\(0.5\pi\)</span> radians. A simulation is labelled a <strong>success</strong> if the final angles are within ±0.05 rad and velocities are within ±0.05 rad/s of zero. We visualise the results by colouring successful and unsuccessful initial conditions in the plane.</p>
</section>
<section id="monte-carlo-robustness-analysis">
<h3>Monte Carlo robustness analysis<a class="headerlink" href="#monte-carlo-robustness-analysis" title="Link to this heading">¶</a></h3>
<p>In dynamical systems theory the <strong>region of attraction</strong> (also called the domain of attraction) is the set of initial conditions whose trajectories converge to an equilibrium. For an asymptotically stable system this region is an open, invariant set containing the equilibrium; Lyapunov functions are commonly used to estimate its extent.</p>
<p>While the cost function includes a penalty for early failure, it evaluates performance only at nominal or lightly perturbed parameters. To assess robustness under uncertainty we perform a <strong>Monte Carlo</strong> study. Monte Carlo simulation is a universal numerical method that evaluates the behaviour of complex systems by repeatedly sampling random inputs; it is prized for its accuracy and flexibility but its chief disadvantage is the heavy computational cost due to the large number of simulations required. By drawing parameter and initial condition samples from specified distributions and integrating the dynamics for each draw we approximate the probability of success and characterise the distribution of performance metrics.</p>
<p>The procedure adopted here is as follows:</p>
<ol class="arabic simple">
<li><p><strong>Define parameter distributions.</strong> For each physical parameter (mass, length, inertia, friction) we assume a uniform distribution within ±5% of the nominal value.</p></li>
<li><p><strong>Randomise initial conditions.</strong> Initial angles and velocities are sampled uniformly from small ranges around zero; disturbances are added as impulses or sinusoidal forces on the cart.</p></li>
<li><p><strong>Simulate multiple runs.</strong> For each draw we integrate the system with the candidate controller for a fixed duration using an adaptive solver.</p></li>
<li><p><strong>Collect metrics.</strong> We record whether the run stabilises, the integral of squared error (ISE) and the maximum control effort.</p></li>
<li><p><strong>Compute statistics.</strong> The distribution of performance metrics across runs indicates the probability of successful stabilisation and reveals outliers.</p></li>
</ol>
</section>
</section>
<section id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h2>
<section id="simulation-loop-pseudocode">
<h3>Simulation loop pseudocode<a class="headerlink" href="#simulation-loop-pseudocode" title="Link to this heading">¶</a></h3>
<p>The following high‑level pseudocode illustrates the enhanced simulation loop using <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> and event detection:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">compute_control</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
        <span class="k">return</span> <span class="n">dyn</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">event_fall</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Stop integration if either pendulum angle exceeds 90 degrees</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">event_fall</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">event_fall</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">dynamics</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">initial_state</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">events</span><span class="o">=</span><span class="n">event_fall</span><span class="p">,</span> <span class="n">max_step</span><span class="o">=</span><span class="mf">0.01</span>
    <span class="p">)</span>
    <span class="c1"># Compute sliding surface and control histories if needed</span>
    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</section>
<section id="roa-mapping-routine">
<h3>RoA mapping routine<a class="headerlink" href="#roa-mapping-routine" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">map_roa</span><span class="p">(</span><span class="n">grid_bounds</span><span class="p">,</span> <span class="n">grid_density</span><span class="p">):</span>
    <span class="n">theta_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">grid_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid_density</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">th1</span> <span class="ow">in</span> <span class="n">theta_range</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">th2</span> <span class="ow">in</span> <span class="n">theta_range</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">traj</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">)</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># success if angles and rates are near zero</span>
            <span class="n">success</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
                       <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">success</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="monte-carlo-simulation-pseudocode">
<h3>Monte Carlo simulation pseudocode<a class="headerlink" href="#monte-carlo-simulation-pseudocode" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">monte_carlo_runs</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
    <span class="n">successes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ise_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">sample_physics_uniform</span><span class="p">(</span><span class="err">±</span><span class="mi">5</span><span class="o">%</span><span class="p">)</span>
        <span class="n">pendulum</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">sample_initial_state</span><span class="p">()</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">traj</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">)</span>
        <span class="c1"># Compute ISE on cart and pendulum angles</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># [x, theta1, theta2]</span>
        <span class="n">ise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">error</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">ise_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ise</span><span class="p">)</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">):</span>
            <span class="n">successes</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">success_rate</span> <span class="o">=</span> <span class="n">successes</span> <span class="o">/</span> <span class="n">n_runs</span>
    <span class="k">return</span> <span class="n">success_rate</span><span class="p">,</span> <span class="n">ise_values</span>
</pre></div>
</div>
<p>These routines form the backbone of the enhanced simulation framework. Additional modules compute the PSO cost and handle integration of the moving‑average and Kalman filters within the control loop.</p>
</section>
</section>
<section id="experimental-scenarios-and-results">
<h2>Experimental Scenarios and Results<a class="headerlink" href="#experimental-scenarios-and-results" title="Link to this heading">¶</a></h2>
<section id="region-of-attraction">
<h3>Region of attraction<a class="headerlink" href="#region-of-attraction" title="Link to this heading">¶</a></h3>
<p>Using the routine described above we mapped the region of attraction for the baseline classical SMC. The data reveal a <strong>very small region of attraction</strong>: only states within approximately ±0.02 rad in both angles stabilised. Outside this region the pendulums fell or the solver diverged, highlighting the need for a swing‑up controller or adaptive gains to enlarge the basin of attraction.</p>
</section>
<section id="step-versus-sinusoidal-tracking">
<h3>Step versus sinusoidal tracking<a class="headerlink" href="#step-versus-sinusoidal-tracking" title="Link to this heading">¶</a></h3>
<p>To assess tracking performance we simulated two reference signals: a <strong>unit step</strong> applied to the cart and a <strong>sinusoidal reference</strong> of amplitude 0.1 m and frequency 0.1 Hz. The step input causes a sharp transient; the SMC brings the angles back to zero within roughly 3 s but exhibits some overshoot. In the sinusoidal case the controller tracks the slow oscillation with small phase lag. However, the presence of chattering is visible as small oscillations, which motivates the use of a boundary layer and filtering.</p>
</section>
<section id="monte-carlo-performance-histogram">
<h3>Monte Carlo performance histogram<a class="headerlink" href="#monte-carlo-performance-histogram" title="Link to this heading">¶</a></h3>
<p>A Monte Carlo run with 30 random parameter draws and initial states produced a wide spread of performance: while roughly half of the runs achieved ISE values below 0.05 rad²·s, a significant tail extends to larger errors. Approximately 40% of the runs failed to stabilise within the simulation time, underscoring the sensitivity of the baseline controller to parameter perturbations. Integrating the Kalman filter and tuning the boundary layer reduced the variance of ISE across runs.</p>
</section>
</section>
<section id="robustness-analysis">
<h2>Robustness Analysis<a class="headerlink" href="#robustness-analysis" title="Link to this heading">¶</a></h2>
<p>The Monte Carlo experiment yields a <strong>success rate of approximately 60%</strong> for the baseline classical SMC under ±5% parameter uncertainties. Runs that failed either saw one pendulum fall early or exhibited numerical instability due to stiff dynamics. Successful runs tended to start from initial angles within ±0.02 rad and benefit from favourable parameter combinations (lighter pendulums and lower friction). The distribution of ISE values suggests that tuning the controller gains via PSO and augmenting the estimator with a Kalman filter can substantially improve robustness. For example, experiments using the Kalman filter reduced the maximum ISE to below 0.1 rad²·s and increased the success rate to around 80%. However, computational overhead increased due to the matrix operations required for the filter and the implicit integrator.</p>
</section>
<section id="limitations-and-future-work">
<h2>Limitations and Future Work<a class="headerlink" href="#limitations-and-future-work" title="Link to this heading">¶</a></h2>
<p>Several limitations remain in the current simulation study:</p>
<ul class="simple">
<li><p><strong>Small region of attraction.</strong> The classical SMC fails for moderate initial angles. Extending the RoA requires either a swing‑up controller to bring the pendulums near the upright equilibrium or adaptive SMC variants with time‑varying gains.</p></li>
<li><p><strong>Model mismatch and unmodelled dynamics.</strong> The simulator neglects motor dynamics, belt compliance and sensor quantisation beyond simple additive noise. Implementing hardware‑in‑the‑loop (HIL) tests will reveal additional non‑linearities and delays.</p></li>
<li><p><strong>Simplistic noise models.</strong> White Gaussian noise and uniform parameter perturbations may not reflect real‑world disturbances. Future work could use coloured noise and correlated uncertainties.</p></li>
<li><p><strong>Computational cost.</strong> Stiff integrators and the Kalman filter increase computational time. Real‑time implementation may require code optimisation or reduced‑order models.</p></li>
</ul>
<p>Future efforts should focus on designing a swing‑up controller, implementing adaptive sliding mode or super‑twisting algorithms, and performing HIL experiments. Incorporating friction estimation and modelling actuator dynamics will further bridge the gap between simulation and reality.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>This report presents a comprehensive analysis of the double inverted pendulum simulation framework and proposes several enhancements. The baseline fixed‑step simulation using a classical sliding mode controller suffers from numerical stiffness, a tiny region of attraction and sensitivity to parameter perturbations. Replacing the fixed‑step integrator with an adaptive stiff solver such as <code class="docutils literal notranslate"><span class="pre">Radau</span></code> improves numerical stability. Introducing a boundary layer in the switching law mitigates chattering, while applying moving‑average and Kalman filters reduces measurement noise. A refined PSO cost function balances state error, control effort, control slew and sliding variable. Mapping the region of attraction and performing Monte Carlo analyses reveal the limitations of the baseline controller and quantify robustness. The proposed enhancements lay the groundwork for more reliable control and pave the way toward practical implementation and hardware‑in‑the‑loop testing.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>[1] V. I. Utkin, “Sliding mode control design principles and applications to electric drives,” <em>IEEE Transactions on Industrial Electronics</em>, vol. 40, no. 1, pp. 23–36, 1993.</p>
<p>[2] J. Gaber, “Observer‑free sliding mode control via structured decomposition: a smooth and bounded control framework,” <em>arXiv preprint</em>, 2025.</p>
<p>[3] Z. Gong, Y. Ba, M. Zhang and Y. Guo, “Robust sliding mode control of the permanent magnet synchronous motor with an improved power reaching law,” <em>Energies</em>, vol. 15, no. 5, art. 1935, 2022.</p>
<p>[4] S. Ekanathan, O. Smith and C. Rackauckas, “A fully adaptive Radau method for the efficient solution of stiff ordinary differential equations at low tolerances,” <em>arXiv preprint</em>, 2025.</p>
<p>[5] D. Freitas, L. G. Lopes and F. Morgado‑Dias, “Particle swarm optimization: a historical review up to the current developments,” <em>Entropy</em>, vol. 22, p. 362, 2020.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="results-analysis.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Results &amp; Analysis</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="smc-theory.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">SMC Theory</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">PSO Optimization</a><ul>
<li><a class="reference internal" href="#introduction-and-background">Introduction and Background</a></li>
<li><a class="reference internal" href="#simulation-framework-challenges">Simulation Framework Challenges</a><ul>
<li><a class="reference internal" href="#numerical-stiffness-from-discontinuous-control">Numerical stiffness from discontinuous control</a></li>
<li><a class="reference internal" href="#limitations-of-the-fixedstep-simulation">Limitations of the fixed–step simulation</a></li>
<li><a class="reference internal" href="#need-for-adaptive-stiff-integrators">Need for adaptive stiff integrators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposed-enhancements-and-methodology">Proposed Enhancements and Methodology</a><ul>
<li><a class="reference internal" href="#adaptive-integrators-and-event-handling">Adaptive integrators and event handling</a></li>
<li><a class="reference internal" href="#chattering-mitigation-via-boundary-layer">Chattering mitigation via boundary layer</a></li>
<li><a class="reference internal" href="#filtering-noisy-measurements">Filtering noisy measurements</a></li>
<li><a class="reference internal" href="#improved-pso-cost-function">Improved PSO cost function</a></li>
<li><a class="reference internal" href="#regionofattraction-mapping">Region‑of‑attraction mapping</a></li>
<li><a class="reference internal" href="#monte-carlo-robustness-analysis">Monte Carlo robustness analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li><a class="reference internal" href="#simulation-loop-pseudocode">Simulation loop pseudocode</a></li>
<li><a class="reference internal" href="#roa-mapping-routine">RoA mapping routine</a></li>
<li><a class="reference internal" href="#monte-carlo-simulation-pseudocode">Monte Carlo simulation pseudocode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#experimental-scenarios-and-results">Experimental Scenarios and Results</a><ul>
<li><a class="reference internal" href="#region-of-attraction">Region of attraction</a></li>
<li><a class="reference internal" href="#step-versus-sinusoidal-tracking">Step versus sinusoidal tracking</a></li>
<li><a class="reference internal" href="#monte-carlo-performance-histogram">Monte Carlo performance histogram</a></li>
</ul>
</li>
<li><a class="reference internal" href="#robustness-analysis">Robustness Analysis</a></li>
<li><a class="reference internal" href="#limitations-and-future-work">Limitations and Future Work</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>