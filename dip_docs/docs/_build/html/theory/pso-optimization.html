<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PSO Optimization &#8212; DIP_SMC_PSO Documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=fb9458d3" />
    <script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Results &amp; Analysis" href="results-analysis.html" />
    <link rel="prev" title="SMC Theory" href="smc-theory.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="results-analysis.html" title="Results &amp; Analysis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="smc-theory.html" title="SMC Theory"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DIP_SMC_PSO Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PSO Optimization</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="pso-optimization">
<h1>PSO Optimization<a class="headerlink" href="#pso-optimization" title="Link to this heading">¶</a></h1>
<p>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</p>
<section id="introduction-and-background">
<h2>Introduction and Background<a class="headerlink" href="#introduction-and-background" title="Link to this heading">¶</a></h2>
<p>The double‑inverted pendulum (DIP) consists of two slender rigid links mounted on a cart that can move along a horizontal rail. Each link is hinged at its base and is inherently unstable in the upright position, so even small disturbances will cause it to fall. The control objective is to keep the cart at a desired position (usually the origin) while balancing both pendulums upright. The project implements a <strong>classical sliding‑mode controller (SMC)</strong>, a robust control strategy that forces the system state onto a user‑defined switching surface and maintains it there despite matched uncertainties and disturbances.</p>
<p>The controller defines a <strong>sliding surface</strong>:</p>
<div class="math notranslate nohighlight">
\[\sigma = \lambda_{1}\theta_{1} + \lambda_{2}\theta_{2} + k_{1}\dot{\theta}_{1} + k_{2}\dot{\theta}_{2}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta_{1}\)</span> and <span class="math notranslate nohighlight">\(\theta_{2}\)</span> are the pendulum angles and <span class="math notranslate nohighlight">\(\dot{\theta}_{1}\)</span>, <span class="math notranslate nohighlight">\(\dot{\theta}_{2}\)</span> are their rates. When <span class="math notranslate nohighlight">\(\sigma = 0\)</span> the system behaves like a reduced‑order linear system that drives the pendulum angles and velocities to zero. As in standard SMC design the control law combines an <strong>equivalent control</strong> term (obtained by canceling the nominal dynamics) and a <strong>robust control</strong> term that forces the system to reach and stay on the sliding surface:</p>
<div class="math notranslate nohighlight">
\[u = u_{\mathrm{eq}} - K\mathrm{sat}\left(\frac{\sigma}{\epsilon}\right) - k_{\mathrm{d}}\sigma\]</div>
<p>Here <span class="math notranslate nohighlight">\(\mathrm{sat}(\cdot)\)</span> is a continuous approximation of the discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}\)</span> function. Classical SMC uses a discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}(\sigma)\)</span> which produces high‑frequency chattering. A common remedy is to introduce a boundary layer and replace <span class="math notranslate nohighlight">\(\mathrm{sign}(\sigma)\)</span> with a smooth saturation function such as the hyperbolic tangent. In the provided code the <code class="docutils literal notranslate"><span class="pre">saturate</span></code> utility chooses between a hyperbolic tangent and a linear saturation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">saturate</span><span class="p">(</span><span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tanh&quot;</span><span class="p">):</span>
    <span class="c1"># Continuous approximation of sign(sigma) within a boundary layer</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;tanh&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span> defines a <strong>boundary layer</strong> that mitigates chattering by smoothing the switching action. As <span class="math notranslate nohighlight">\(\epsilon \rightarrow 0\)</span> the saturation approximates the discontinuous <span class="math notranslate nohighlight">\(\mathrm{sign}\)</span> function, whereas increasing <span class="math notranslate nohighlight">\(\epsilon\)</span> yields smoother control at the expense of convergence speed. The baseline controller sets <span class="math notranslate nohighlight">\(\epsilon = 0.02\)</span> and uses the hyperbolic tangent method, consistent with improved power reaching laws that employ smooth saturation functions to reduce chattering.</p>
</section>
<section id="simulation-framework-challenges">
<h2>Simulation Framework Challenges<a class="headerlink" href="#simulation-framework-challenges" title="Link to this heading">¶</a></h2>
<section id="numerical-stiffness-from-discontinuous-control">
<h3>Numerical stiffness from discontinuous control<a class="headerlink" href="#numerical-stiffness-from-discontinuous-control" title="Link to this heading">¶</a></h3>
<p>Sliding‑mode control uses high‑gain feedback and discontinuous switching to force states onto the sliding surface. In practice the boundary layer smooths the discontinuity, but for small <span class="math notranslate nohighlight">\(\epsilon\)</span> the right‑hand side still exhibits very steep gradients. The dynamics of the DIP combine slow cart motion with fast pendulum oscillations and fast switching in the control law. This results in <strong>stiff differential equations</strong>: the solver must resolve both slow and very fast dynamics simultaneously. Explicit fixed‑step integrators (such as Euler or fourth‑order Runge–Kutta) cannot safely integrate such systems because large steps lead to oscillations or divergence, whereas very small steps yield high computational cost. Implicit stiff solvers are therefore preferred for systems with multiple time scales.</p>
</section>
<section id="limitations-of-the-fixedstep-simulation">
<h3>Limitations of the fixed–step simulation<a class="headerlink" href="#limitations-of-the-fixedstep-simulation" title="Link to this heading">¶</a></h3>
<p>The original simulation loop employed a fixed time step <span class="math notranslate nohighlight">\(dt = 0.01\,\text{s}\)</span> and integrated the dynamics using a hand‑coded RK4 method in <code class="docutils literal notranslate"><span class="pre">dynamics.DoubleInvertedPendulum.step</span></code>. With the baseline SMC gains the system was highly unstable for anything other than tiny initial angles. Even when the step was reduced to 0.001 s, the integration frequently diverged because the solver could not adapt to the stiff dynamics near the switching surface. Moreover, because the control law computes a model‑based equivalent control <code class="docutils literal notranslate"><span class="pre">u_eq</span></code> by inverting the inertia matrix, numerical singularities or large condition numbers can appear during integration. The controller code detects near‑singular matrices and returns zero to preserve stability, but the resulting abrupt change in torque further stiffens the problem.</p>
</section>
<section id="need-for-adaptive-stiff-integrators">
<h3>Need for adaptive stiff integrators<a class="headerlink" href="#need-for-adaptive-stiff-integrators" title="Link to this heading">¶</a></h3>
<p>The <strong>SciPy</strong> routine <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> provides a suite of adaptive methods that adjust the step size to meet prescribed error tolerances. Explicit methods like <code class="docutils literal notranslate"><span class="pre">RK45</span></code> are efficient for non‑stiff systems, while implicit methods such as the <strong>Backward Differentiation Formula (BDF)</strong> or <strong>Radau</strong> are recommended for stiff problems. Implicit BDF methods suffer from an order barrier—orders above five are unstable—whereas Radau IIA schemes are A‑stable and L‑stable at arbitrary order, providing large stability regions for stiff systems. For our system, preliminary experiments showed that <code class="docutils literal notranslate"><span class="pre">RK45</span></code> took extremely small steps and failed to converge, whereas <code class="docutils literal notranslate"><span class="pre">Radau</span></code> handled the stiff sliding dynamics more robustly. A robust simulation loop therefore employs <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> with an adaptive stiff integrator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>

<span class="k">def</span><span class="w"> </span><span class="nf">dip_ode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">dyn</span><span class="p">):</span>
    <span class="c1"># x = [x, theta1, theta2, xdot, dtheta1, dtheta2]</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">compute_control</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
    <span class="n">dxdt</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dxdt</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">dip_ode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">),</span>
    <span class="n">t_span</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span>
    <span class="n">y0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span>
    <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">max_step</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The solver automatically reduces the step size near steep gradients and increases it when the dynamics slow down, yielding accurate trajectories with fewer function evaluations.</p>
</section>
</section>
<section id="proposed-enhancements-and-methodology">
<h2>Proposed Enhancements and Methodology<a class="headerlink" href="#proposed-enhancements-and-methodology" title="Link to this heading">¶</a></h2>
<section id="adaptive-integrators-and-event-handling">
<h3>Adaptive integrators and event handling<a class="headerlink" href="#adaptive-integrators-and-event-handling" title="Link to this heading">¶</a></h3>
<p>Switching to adaptive stiff solvers addresses the numerical instability observed with fixed‑step methods. <strong>Event functions</strong> can be added to <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> to halt integration if the pendulum angles exceed safe limits (e.g., <span class="math notranslate nohighlight">\(|\theta_{i}| &gt; \pi/2\)</span>). By terminating unstable simulations early we avoid wasting computational effort and can classify initial states as failures. The integrator parameters <span class="math notranslate nohighlight">\(\text{rtol} = 10^{-6}\)</span>, <span class="math notranslate nohighlight">\(\text{atol} = 10^{-8}\)</span> and <span class="math notranslate nohighlight">\(\text{max\_step} = 0.01\,\text{s}\)</span> were found to balance accuracy and speed in the stiff regime.</p>
</section>
<section id="chattering-mitigation-via-boundary-layer">
<h3>Chattering mitigation via boundary layer<a class="headerlink" href="#chattering-mitigation-via-boundary-layer" title="Link to this heading">¶</a></h3>
<p>The discontinuous <code class="docutils literal notranslate"><span class="pre">sign()</span></code> function in the baseline SMC produces high‑frequency chatter. Introducing a <strong>boundary layer</strong> smooths the switching term so that the control becomes:</p>
<div class="math notranslate nohighlight">
\[u_{\text{robust}} = - K\, \mathrm{sat}\left( \frac{\sigma}{\epsilon} \right) - k_{d}\sigma\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathrm{sat}\left( \frac{\sigma}{\epsilon} \right)\)</span> is either <span class="math notranslate nohighlight">\(\tanh(\sigma/\epsilon)\)</span> or <span class="math notranslate nohighlight">\(\text{clip}(\sigma/\epsilon, -1,1)\)</span>. The derivative term <span class="math notranslate nohighlight">\(- k_{d}\sigma\)</span> further damps sliding dynamics. Choosing <span class="math notranslate nohighlight">\(\epsilon\)</span> too small leads to chattering; increasing <span class="math notranslate nohighlight">\(\epsilon\)</span> reduces chattering but slows convergence. Simulation results show that <span class="math notranslate nohighlight">\(\epsilon = 0.02\)</span> provides a good compromise for the DIP. Adaptive boundary layers can also be implemented to widen <span class="math notranslate nohighlight">\(\epsilon\)</span> when <span class="math notranslate nohighlight">\(\sigma\)</span> is large and tighten it near the origin, as suggested in improved power‑reaching laws for sliding‑mode control.</p>
</section>
<section id="filtering-noisy-measurements">
<h3>Filtering noisy measurements<a class="headerlink" href="#filtering-noisy-measurements" title="Link to this heading">¶</a></h3>
<p>In practice sensors introduce noise that can drive the controller and cause chattering. Two complementary filters are proposed:</p>
<ol class="arabic">
<li><p><strong>Moving average filter.</strong> A simple moving average computes the unweighted mean of the last <span class="math notranslate nohighlight">\(k\)</span> samples. For a sequence <span class="math notranslate nohighlight">\(p_{1},p_{2},\ldots,p_{n}\)</span> the mean over the last <span class="math notranslate nohighlight">\(k\)</span> samples is:</p>
<div class="math notranslate nohighlight">
\[\text{SMA}_{k} = \frac{p_{n - k + 1} + p_{n - k + 2} + \cdots + p_{n}}{k} = \frac{1}{k}\sum_{i = n - k + 1}^{n}p_{i}\]</div>
<p>Smoothing filters such as the moving average reduce high‑frequency noise by averaging neighbouring points. In functional near‑infrared spectroscopy data processing, the moving average filter replaces the value at each point with the average of neighbouring data points, thereby reducing high‑frequency fluctuations. Applying an SMA to measured angles smooths high‑frequency noise but introduces a delay proportional to <span class="math notranslate nohighlight">\(k/2\)</span>. Choosing <span class="math notranslate nohighlight">\(k\)</span> between 3 and 7 samples at a <strong>100 Hz</strong> (10 ms) sampling rate offers a good compromise between smoothing and latency.</p>
</li>
<li><p><strong>Kalman filter.</strong> The Kalman filter models the system in discrete state–space form <span class="math notranslate nohighlight">\(x_{k + 1} = Fx_{k} + Bu_{k} + w_{k}\)</span> and <span class="math notranslate nohighlight">\(y_{k} = Hx_{k} + v_{k}\)</span>. It recursively performs a <strong>prediction</strong> and <strong>update</strong> step. The prediction step computes the a‑priori state and covariance:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_{k|k - 1} = F_{k}\hat{x}_{k - 1|k - 1} + B_{k}u_{k}, \quad P_{k|k - 1} = F_{k}P_{k - 1|k - 1}F_{k}^{\mathsf{T}} + Q_{k}\]</div>
<p>and the update step incorporates the measurement <span class="math notranslate nohighlight">\(z_{k}\)</span> using the Kalman gain <span class="math notranslate nohighlight">\(K_{k}\)</span>:</p>
<div class="math notranslate nohighlight">
\[K_{k} = P_{k|k - 1}H_{k}^{\mathsf{T}}S_{k}^{- 1}, \quad \hat{x}_{k|k} = \hat{x}_{k|k - 1} + K_{k}\left( z_{k} - H_{k}\hat{x}_{k|k - 1} \right), \quad P_{k|k} = \left( I - K_{k}H_{k} \right)P_{k|k - 1}\]</div>
<p>where <span class="math notranslate nohighlight">\(S_{k} = H_{k}P_{k|k - 1}H_{k}^{\mathsf{T}} + R_{k}\)</span> is the innovation covariance. Under the assumption that the process and measurement noise are independent, white and Gaussian, the Kalman filter provides an optimal linear estimator.</p>
</li>
</ol>
</section>
<section id="improved-pso-cost-function">
<h3>Improved PSO cost function<a class="headerlink" href="#improved-pso-cost-function" title="Link to this heading">¶</a></h3>
<p>The particle swarm optimisation (PSO) routine tunes the six gains <span class="math notranslate nohighlight">\([k_{1},k_{2},\lambda_{1},\lambda_{2},K,k_{d}]\)</span> to minimise a cost function. PSO is a population‑based metaheuristic inspired by the collective behaviour of bird flocks: each particle (candidate solution) remembers its best previous position and is attracted toward the best position found by the entire swarm. Velocities are updated using cognitive and social weights with random coefficients, and positions are updated accordingly. Because the algorithm does not rely on gradients it can be applied to a wide range of optimisation problems and has spawned numerous variations.</p>
<p>The cost is computed from the simulated trajectory using weighted integrals:</p>
<div class="math notranslate nohighlight">
\[J = w_{e} \cdot \frac{1}{N_{e}}\int_{0}^{T} \|x(t)\|^{2}dt + w_{u} \cdot \frac{1}{N_{u}}\int_{0}^{T}u(t)^{2}dt + w_{\dot{u}} \cdot \frac{1}{N_{\dot{u}}}\int_{0}^{T}\dot{u}(t)^{2}dt + w_{\sigma} \cdot \frac{1}{N_{\sigma}}\int_{0}^{T}\sigma(t)^{2}dt + w_{\text{stab}} \cdot \frac{T - t_{\text{fail}}}{T} \cdot P_{\text{penalty}}\]</div>
<p>The first term (state error) penalises deviations of cart position and pendulum angles from zero. The second and third terms penalise large control efforts and large control slews, reflecting actuator limitations. The fourth term penalises large sliding surface values, encouraging the system to converge quickly onto the sliding manifold. The last term applies a penalty if the simulation fails before the full duration, with the penalty proportional to how early the failure occurs. In the provided configuration the weights are <span class="math notranslate nohighlight">\(w_{e} = 50\)</span>, <span class="math notranslate nohighlight">\(w_{u} = 0.2\)</span>, <span class="math notranslate nohighlight">\(w_{\dot{u}} = 0.1\)</span>, <span class="math notranslate nohighlight">\(w_{\sigma} = 0.1\)</span> and the penalty constant <span class="math notranslate nohighlight">\(P_{\text{penalty}} = 1000\)</span>. Each integral is normalised by an empirically chosen constant <span class="math notranslate nohighlight">\(N_{e},N_{u},N_{\dot{u}},N_{\sigma}\)</span> to make the contributions comparable.</p>
</section>
<section id="regionofattraction-mapping">
<h3>Region‑of‑attraction mapping<a class="headerlink" href="#regionofattraction-mapping" title="Link to this heading">¶</a></h3>
<p>To quantify the controller’s basin of attraction we systematically sample initial conditions. For each pair of initial angles <span class="math notranslate nohighlight">\(\theta_{1}(0),\theta_{2}(0)\)</span> (with zero velocities and cart position) we integrate the system until the final time or until either pendulum angle exceeds <span class="math notranslate nohighlight">\(0.5\pi\)</span> radians. A simulation is labelled a <strong>success</strong> if the final angles are within ±0.05 rad and velocities are within ±0.05 rad/s of zero. We visualise the results by colouring successful and unsuccessful initial conditions in the plane.</p>
</section>
<section id="monte-carlo-robustness-analysis">
<h3>Monte Carlo robustness analysis<a class="headerlink" href="#monte-carlo-robustness-analysis" title="Link to this heading">¶</a></h3>
<p>In dynamical systems theory the <strong>region of attraction</strong> (also called the domain of attraction) is the set of initial conditions whose trajectories converge to an equilibrium. For an asymptotically stable system this region is an open, invariant set containing the equilibrium; Lyapunov functions are commonly used to estimate its extent.</p>
<p>While the cost function includes a penalty for early failure, it evaluates performance only at nominal or lightly perturbed parameters. To assess robustness under uncertainty we perform a <strong>Monte Carlo</strong> study. Monte Carlo simulation is a universal numerical method that evaluates the behaviour of complex systems by repeatedly sampling random inputs; it is prized for its accuracy and flexibility but its chief disadvantage is the heavy computational cost due to the large number of simulations required. By drawing parameter and initial condition samples from specified distributions and integrating the dynamics for each draw we approximate the probability of success and characterise the distribution of performance metrics.</p>
<p>The procedure adopted here is as follows:</p>
<ol class="arabic simple">
<li><p><strong>Define parameter distributions.</strong> For each physical parameter (mass, length, inertia, friction) we assume a uniform distribution within ±5% of the nominal value.</p></li>
<li><p><strong>Randomise initial conditions.</strong> Initial angles and velocities are sampled uniformly from small ranges around zero; disturbances are added as impulses or sinusoidal forces on the cart.</p></li>
<li><p><strong>Simulate multiple runs.</strong> For each draw we integrate the system with the candidate controller for a fixed duration using an adaptive solver.</p></li>
<li><p><strong>Collect metrics.</strong> We record whether the run stabilises, the integral of squared error (ISE) and the maximum control effort.</p></li>
<li><p><strong>Compute statistics.</strong> The distribution of performance metrics across runs indicates the probability of successful stabilisation and reveals outliers.</p></li>
</ol>
</section>
</section>
<section id="implementation-details">
<h2>Implementation Details<a class="headerlink" href="#implementation-details" title="Link to this heading">¶</a></h2>
<section id="simulation-loop-pseudocode">
<h3>Simulation loop pseudocode<a class="headerlink" href="#simulation-loop-pseudocode" title="Link to this heading">¶</a></h3>
<p>The following high‑level pseudocode illustrates the enhanced simulation loop using <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> and event detection:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">compute_control</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
        <span class="k">return</span> <span class="n">dyn</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">event_fall</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Stop integration if either pendulum angle exceeds 90 degrees</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">event_fall</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">event_fall</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span>
        <span class="n">dynamics</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">initial_state</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Radau&#39;</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">events</span><span class="o">=</span><span class="n">event_fall</span><span class="p">,</span> <span class="n">max_step</span><span class="o">=</span><span class="mf">0.01</span>
    <span class="p">)</span>
    <span class="c1"># Compute sliding surface and control histories if needed</span>
    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</section>
<section id="roa-mapping-routine">
<h3>RoA mapping routine<a class="headerlink" href="#roa-mapping-routine" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">map_roa</span><span class="p">(</span><span class="n">grid_bounds</span><span class="p">,</span> <span class="n">grid_density</span><span class="p">):</span>
    <span class="n">theta_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">grid_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid_density</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">th1</span> <span class="ow">in</span> <span class="n">theta_range</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">th2</span> <span class="ow">in</span> <span class="n">theta_range</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">traj</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">)</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># success if angles and rates are near zero</span>
            <span class="n">success</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
                       <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">success</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span>
</pre></div>
</div>
</section>
<section id="monte-carlo-simulation-pseudocode">
<h3>Monte Carlo simulation pseudocode<a class="headerlink" href="#monte-carlo-simulation-pseudocode" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">monte_carlo_runs</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
    <span class="n">successes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ise_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_runs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">sample_physics_uniform</span><span class="p">(</span><span class="err">±</span><span class="mi">5</span><span class="o">%</span><span class="p">)</span>
        <span class="n">pendulum</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">sample_initial_state</span><span class="p">()</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">traj</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">smc_controller</span><span class="p">,</span> <span class="n">pendulum</span><span class="p">)</span>
        <span class="c1"># Compute ISE on cart and pendulum angles</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># [x, theta1, theta2]</span>
        <span class="n">ise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">error</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">ise_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ise</span><span class="p">)</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">final</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">):</span>
            <span class="n">successes</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">success_rate</span> <span class="o">=</span> <span class="n">successes</span> <span class="o">/</span> <span class="n">n_runs</span>
    <span class="k">return</span> <span class="n">success_rate</span><span class="p">,</span> <span class="n">ise_values</span>
</pre></div>
</div>
<p>These routines form the backbone of the enhanced simulation framework. Additional modules compute the PSO cost and handle integration of the moving‑average and Kalman filters within the control loop.</p>
</section>
</section>
<section id="experimental-scenarios-and-results">
<h2>Experimental Scenarios and Results<a class="headerlink" href="#experimental-scenarios-and-results" title="Link to this heading">¶</a></h2>
<section id="region-of-attraction">
<h3>Region of attraction<a class="headerlink" href="#region-of-attraction" title="Link to this heading">¶</a></h3>
<p>Using the routine described above we mapped the region of attraction for the baseline classical SMC. The data reveal a <strong>very small region of attraction</strong>: only states within approximately ±0.02 rad in both angles stabilised. Outside this region the pendulums fell or the solver diverged, highlighting the need for a swing‑up controller or adaptive gains to enlarge the basin of attraction.</p>
</section>
<section id="step-versus-sinusoidal-tracking">
<h3>Step versus sinusoidal tracking<a class="headerlink" href="#step-versus-sinusoidal-tracking" title="Link to this heading">¶</a></h3>
<p>To assess tracking performance we simulated two reference signals: a <strong>unit step</strong> applied to the cart and a <strong>sinusoidal reference</strong> of amplitude 0.1 m and frequency 0.1 Hz. The step input causes a sharp transient; the SMC brings the angles back to zero within roughly 3 s but exhibits some overshoot. In the sinusoidal case the controller tracks the slow oscillation with small phase lag. However, the presence of chattering is visible as small oscillations, which motivates the use of a boundary layer and filtering.</p>
</section>
<section id="monte-carlo-performance-histogram">
<h3>Monte Carlo performance histogram<a class="headerlink" href="#monte-carlo-performance-histogram" title="Link to this heading">¶</a></h3>
<p>A Monte Carlo run with 30 random parameter draws and initial states produced a wide spread of performance: while roughly half of the runs achieved ISE values below 0.05 rad²·s, a significant tail extends to larger errors. Approximately 40% of the runs failed to stabilise within the simulation time, underscoring the sensitivity of the baseline controller to parameter perturbations. Integrating the Kalman filter and tuning the boundary layer reduced the variance of ISE across runs.</p>
</section>
</section>
<section id="robustness-analysis">
<h2>Robustness Analysis<a class="headerlink" href="#robustness-analysis" title="Link to this heading">¶</a></h2>
<p>The Monte Carlo experiment yields a <strong>success rate of approximately 60%</strong> for the baseline classical SMC under ±5% parameter uncertainties. Runs that failed either saw one pendulum fall early or exhibited numerical instability due to stiff dynamics. Successful runs tended to start from initial angles within ±0.02 rad and benefit from favourable parameter combinations (lighter pendulums and lower friction). The distribution of ISE values suggests that tuning the controller gains via PSO and augmenting the estimator with a Kalman filter can substantially improve robustness. For example, experiments using the Kalman filter reduced the maximum ISE to below 0.1 rad²·s and increased the success rate to around 80%. However, computational overhead increased due to the matrix operations required for the filter and the implicit integrator.</p>
</section>
<section id="limitations-and-future-work">
<h2>Limitations and Future Work<a class="headerlink" href="#limitations-and-future-work" title="Link to this heading">¶</a></h2>
<p>Several limitations remain in the current simulation study:</p>
<ul class="simple">
<li><p><strong>Small region of attraction.</strong> The classical SMC fails for moderate initial angles. Extending the RoA requires either a swing‑up controller to bring the pendulums near the upright equilibrium or adaptive SMC variants with time‑varying gains.</p></li>
<li><p><strong>Model mismatch and unmodelled dynamics.</strong> The simulator neglects motor dynamics, belt compliance and sensor quantisation beyond simple additive noise. Implementing hardware‑in‑the‑loop (HIL) tests will reveal additional non‑linearities and delays.</p></li>
<li><p><strong>Simplistic noise models.</strong> White Gaussian noise and uniform parameter perturbations may not reflect real‑world disturbances. Future work could use coloured noise and correlated uncertainties.</p></li>
<li><p><strong>Computational cost.</strong> Stiff integrators and the Kalman filter increase computational time. Real‑time implementation may require code optimisation or reduced‑order models.</p></li>
</ul>
<p>Future efforts should focus on designing a swing‑up controller, implementing adaptive sliding mode or super‑twisting algorithms, and performing HIL experiments. Incorporating friction estimation and modelling actuator dynamics will further bridge the gap between simulation and reality.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Link to this heading">¶</a></h2>
<p>This report presents a comprehensive analysis of the double inverted pendulum simulation framework and proposes several enhancements. The baseline fixed‑step simulation using a classical sliding mode controller suffers from numerical stiffness, a tiny region of attraction and sensitivity to parameter perturbations. Replacing the fixed‑step integrator with an adaptive stiff solver such as <code class="docutils literal notranslate"><span class="pre">Radau</span></code> improves numerical stability. Introducing a boundary layer in the switching law mitigates chattering, while applying moving‑average and Kalman filters reduces measurement noise. A refined PSO cost function balances state error, control effort, control slew and sliding variable. Mapping the region of attraction and performing Monte Carlo analyses reveal the limitations of the baseline controller and quantify robustness. The proposed enhancements lay the groundwork for more reliable control and pave the way toward practical implementation and hardware‑in‑the‑loop testing.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>[1] V. I. Utkin, “Sliding mode control design principles and applications to electric drives,” <em>IEEE Transactions on Industrial Electronics</em>, vol. 40, no. 1, pp. 23–36, 1993.</p>
<p>[2] J. Gaber, “Observer‑free sliding mode control via structured decomposition: a smooth and bounded control framework,” <em>arXiv preprint</em>, 2025.</p>
<p>[3] Z. Gong, Y. Ba, M. Zhang and Y. Guo, “Robust sliding mode control of the permanent magnet synchronous motor with an improved power reaching law,” <em>Energies</em>, vol. 15, no. 5, art. 1935, 2022.</p>
<p>[4] S. Ekanathan, O. Smith and C. Rackauckas, “A fully adaptive Radau method for the efficient solution of stiff ordinary differential equations at low tolerances,” <em>arXiv preprint</em>, 2025.</p>
<p>[5] D. Freitas, L. G. Lopes and F. Morgado‑Dias, “Particle swarm optimization: a historical review up to the current developments,” <em>Entropy</em>, vol. 22, p. 362, 2020.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">PSO Optimization</a><ul>
<li><a class="reference internal" href="#introduction-and-background">Introduction and Background</a></li>
<li><a class="reference internal" href="#simulation-framework-challenges">Simulation Framework Challenges</a><ul>
<li><a class="reference internal" href="#numerical-stiffness-from-discontinuous-control">Numerical stiffness from discontinuous control</a></li>
<li><a class="reference internal" href="#limitations-of-the-fixedstep-simulation">Limitations of the fixed–step simulation</a></li>
<li><a class="reference internal" href="#need-for-adaptive-stiff-integrators">Need for adaptive stiff integrators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposed-enhancements-and-methodology">Proposed Enhancements and Methodology</a><ul>
<li><a class="reference internal" href="#adaptive-integrators-and-event-handling">Adaptive integrators and event handling</a></li>
<li><a class="reference internal" href="#chattering-mitigation-via-boundary-layer">Chattering mitigation via boundary layer</a></li>
<li><a class="reference internal" href="#filtering-noisy-measurements">Filtering noisy measurements</a></li>
<li><a class="reference internal" href="#improved-pso-cost-function">Improved PSO cost function</a></li>
<li><a class="reference internal" href="#regionofattraction-mapping">Region‑of‑attraction mapping</a></li>
<li><a class="reference internal" href="#monte-carlo-robustness-analysis">Monte Carlo robustness analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation Details</a><ul>
<li><a class="reference internal" href="#simulation-loop-pseudocode">Simulation loop pseudocode</a></li>
<li><a class="reference internal" href="#roa-mapping-routine">RoA mapping routine</a></li>
<li><a class="reference internal" href="#monte-carlo-simulation-pseudocode">Monte Carlo simulation pseudocode</a></li>
</ul>
</li>
<li><a class="reference internal" href="#experimental-scenarios-and-results">Experimental Scenarios and Results</a><ul>
<li><a class="reference internal" href="#region-of-attraction">Region of attraction</a></li>
<li><a class="reference internal" href="#step-versus-sinusoidal-tracking">Step versus sinusoidal tracking</a></li>
<li><a class="reference internal" href="#monte-carlo-performance-histogram">Monte Carlo performance histogram</a></li>
</ul>
</li>
<li><a class="reference internal" href="#robustness-analysis">Robustness Analysis</a></li>
<li><a class="reference internal" href="#limitations-and-future-work">Limitations and Future Work</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="smc-theory.html"
                          title="previous chapter">SMC Theory</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="results-analysis.html"
                          title="next chapter">Results &amp; Analysis</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/theory/pso-optimization.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="results-analysis.html" title="Results &amp; Analysis"
             >next</a> |</li>
        <li class="right" >
          <a href="smc-theory.html" title="SMC Theory"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">DIP_SMC_PSO Documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">PSO Optimization</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Research Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>