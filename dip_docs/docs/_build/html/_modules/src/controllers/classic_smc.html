<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>src.controllers.classic_smc &#8212; DIP_SMC_PSO Documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=fb9458d3" />
    <script src="../../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DIP_SMC_PSO Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">src.controllers.classic_smc</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for src.controllers.classic_smc</h1><div class="highlight"><pre>
<span></span><span class="c1">#==========================================================================================\\\</span>
<span class="c1">#============================== src/controllers/classic_smc.py ============================\\\</span>
<span class="c1">#==========================================================================================\\\</span>
<span class="c1"># Changed: enforce strict positivity of sliding‑surface and switching gains and</span>
<span class="c1"># allow zero derivative gain; updated docstring to reflect these constraints.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="c1"># robust import for utils.* to support both import styles</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">saturate</span>  <span class="c1"># when repo root on sys.path</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">saturate</span>  <span class="c1"># when importing as src.controllers.*</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">saturate</span>    <span class="c1"># when src itself on sys.path</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.control_outputs</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassicalSMCOutput</span>  <span class="c1"># when repo root on sys.path</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">..utils.control_outputs</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassicalSMCOutput</span>  <span class="c1"># when importing as src.controllers.*</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">utils.control_outputs</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassicalSMCOutput</span>    <span class="c1"># when src itself on sys.path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span>

<span class="c1"># Avoid circular import at runtime</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Hint only; don&#39;t import at runtime to avoid path issues</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">src.core.dynamics</span><span class="w"> </span><span class="kn">import</span> <span class="n">DoubleInvertedPendulum</span>

<div class="viewcode-block" id="ClassicalSMC">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassicalSMC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classical Sliding‑Mode Controller for a double‑inverted pendulum.</span>

<span class="sd">    This controller implements the conventional first‑order sliding‑mode law</span>
<span class="sd">    consisting of a model‑based equivalent control ``u_eq`` and a robust</span>
<span class="sd">    discontinuous term.  The robust term uses a continuous approximation to</span>
<span class="sd">    the sign function (either a hyperbolic tangent or a piecewise‑linear</span>
<span class="sd">    saturation) within a boundary layer of width ``epsilon`` to attenuate</span>
<span class="sd">    chattering.  Introducing a boundary layer around the switching surface</span>
<span class="sd">    replaces the discontinuous signum control with a continuous function,</span>
<span class="sd">    thereby reducing high‑frequency oscillations.  A number of authors</span>
<span class="sd">    note that the boundary‑layer approximation attenuates chattering at</span>
<span class="sd">    the cost of introducing a finite steady‑state tracking error; for</span>
<span class="sd">    example, a discussion of chattering reduction methods emphasises</span>
<span class="sd">    that the boundary‑layer method &quot;reduces chattering but leads to a finite</span>
<span class="sd">    steady state error&quot;.  The user should therefore</span>
<span class="sd">    select ``epsilon`` to balance chattering reduction against steady‑state</span>
<span class="sd">    accuracy.</span>

<span class="sd">    Two switching functions are available: ``tanh`` (smooth hyperbolic</span>
<span class="sd">    tangent) and ``linear`` (piecewise‑linear saturation).  The ``linear``</span>
<span class="sd">    switch approximates the sign function more harshly by clipping the</span>
<span class="sd">    sliding surface directly, which can degrade robustness near the origin</span>
<span class="sd">    because the control gain effectively drops to zero for small errors.</span>
<span class="sd">    In contrast, the ``tanh`` switch retains smoothness and maintains a</span>
<span class="sd">    nonzero slope through the origin, preserving control authority in a</span>
<span class="sd">    neighbourhood of the sliding surface.  Users should prefer</span>
<span class="sd">    ``tanh`` unless there is a compelling reason to adopt the linear</span>
<span class="sd">    saturation and should be aware that linear saturation may cause</span>
<span class="sd">    increased steady‑state error and slower convergence near the origin.</span>

<span class="sd">    A small diagonal ``regularization`` is added to the inertia matrix during</span>
<span class="sd">    inversion to ensure positive definiteness and numerical robustness.</span>
<span class="sd">    Adding a tiny constant to the diagonal of a symmetric matrix is a</span>
<span class="sd">    well‑known regularisation technique: in the context of covariance</span>
<span class="sd">    matrices, Leung and colleagues recommend “adding a small, positive</span>
<span class="sd">    constant to the diagonal” to ensure the matrix is invertible.</span>

<span class="sd">    Parameters are typically supplied by a factory that reads a central</span>
<span class="sd">    configuration.  Each gain vector must contain exactly six elements in the</span>
<span class="sd">    order ``[k1, k2, lam1, lam2, K, kd]``.  The maximum force ``max_force``</span>
<span class="sd">    sets the saturation limit for the final control command.</span>

<span class="sd">    The optional ``controllability_threshold`` parameter decouples</span>
<span class="sd">    controllability from the boundary layer ``epsilon``.  Earlier</span>
<span class="sd">    implementations compared the magnitude of ``L·M^{-1}·B`` against</span>
<span class="sd">    ``epsilon`` to decide whether to compute the equivalent control.  This</span>
<span class="sd">    conflation of chattering mitigation with controllability made it</span>
<span class="sd">    difficult to tune each effect separately.  ``controllability_threshold``</span>
<span class="sd">    defines a lower bound on ``|L·M^{-1}·B|`` below which the equivalent</span>
<span class="sd">    control is suppressed.  If unspecified, a default of ``1e‑4`` is used</span>
<span class="sd">    based on matrix conditioning guidelines.  The</span>
<span class="sd">    boundary layer width ``epsilon`` should therefore be chosen solely to</span>
<span class="sd">    trade off between chattering and steady‑state error, while</span>
<span class="sd">    ``controllability_threshold`` governs when the model‑based feedforward</span>
<span class="sd">    term is applied.</span>

<span class="sd">    **Gain positivity (F‑4.SMCDesign.2 / RC‑04)** – Sliding‑mode theory</span>
<span class="sd">    requires that the sliding‑surface gains ``k1``, ``k2`` and the slope</span>
<span class="sd">    coefficients ``lam1``, ``lam2`` be strictly positive.  Utkin and</span>
<span class="sd">    Levant note that the discontinuous control gain ``k`` must be a</span>
<span class="sd">    positive constant【Rhif2012†L563-L564】, and the slope ``λ`` of the</span>
<span class="sd">    sliding function must be chosen positive to ensure Hurwitz</span>
<span class="sd">    stability【ModelFreeSMC2018†L340-L345】.  The switching gain ``K`` must</span>
<span class="sd">    also be strictly positive to drive the system to the sliding surface,</span>
<span class="sd">    while the derivative gain ``kd`` should be non‑negative to provide</span>
<span class="sd">    damping.  The constructor validates these constraints and raises</span>
<span class="sd">    ``ValueError`` when violated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ClassicalSMC.__init__">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">boundary_layer</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">dynamics_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DoubleInvertedPendulum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
        <span class="n">switch_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tanh&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">boundary_layer_slope</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">controllability_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hysteresis_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the controller.</span>

<span class="sd">        Args:</span>
<span class="sd">            gains: Six gains in the order ``[k1, k2, lam1, lam2, K, kd]``.</span>
<span class="sd">            max_force: Saturation limit for the control input (N).</span>
<span class="sd">            boundary_layer: Boundary layer thickness (epsilon) for chattering reduction.</span>
<span class="sd">            dynamics_model: Dynamics model providing physics matrices via ``_compute_physics_matrices``.</span>
<span class="sd">            regularization: Small value to add to the diagonal of the inertia matrix for numerical stability.</span>
<span class="sd">            **kwargs: Ignored extras to keep factory compatibility.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If ``gains`` does not contain exactly six elements</span>
<span class="sd">                        or if ``boundary_layer`` is not strictly positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate and normalise the supplied gains early.  This makes it</span>
        <span class="c1"># possible for the factory or PSO tuner to reject misconfigured</span>
        <span class="c1"># gain vectors before instantiating the controller.  Accept any</span>
        <span class="c1"># sequence or array-like input and coerce it to a flat NumPy array</span>
        <span class="c1"># of floats.  After validation the gains are unpacked into the</span>
        <span class="c1"># canonical order ``[k1, k2, lam1, lam2, K, kd]``.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_gains</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span>
        <span class="c1"># Coerce to a 1‑D array of floats; ravel() flattens nested sequences</span>
        <span class="n">gains_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gains</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># Store a shallow copy of the gains for external inspection.  Using</span>
        <span class="c1"># list() avoids exposing the internal NumPy array directly.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gains</span> <span class="o">=</span> <span class="n">gains_arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Unpack the gains into individual parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kd</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">gains_arr</span><span class="p">)</span>
        <span class="c1"># Validate shared parameters via central utility.  Positivity of gains</span>
        <span class="c1"># and boundary layers ensures that the sliding surface and switching</span>
        <span class="c1"># function remain well‑defined and stable.</span>
        <span class="c1"># robust import for utils.* to support both import styles</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">src.utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when repo root on sys.path</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">..utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when importing as src.controllers.*</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">utils.control_primitives</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>    <span class="c1"># when src itself on sys.path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_force</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">max_force</span><span class="p">,</span> <span class="s2">&quot;max_force&quot;</span><span class="p">)</span>
        <span class="c1"># Use helpers for the adaptive boundary layer.  The nominal</span>
        <span class="c1"># thickness ``epsilon0`` must be strictly positive, while</span>
        <span class="c1"># ``boundary_layer_slope`` can be zero or positive.  A positive</span>
        <span class="c1"># slope scales the boundary layer with the norm of the sliding</span>
        <span class="c1"># variable, reducing chattering for large errors and shrinking</span>
        <span class="c1"># the layer as the error vanishes【967233543993377†L104-L115】.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon0</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">boundary_layer</span><span class="p">,</span> <span class="s2">&quot;boundary_layer&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">boundary_layer_slope</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon1</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;boundary_layer_slope must be non‑negative&quot;</span><span class="p">)</span>
        <span class="c1"># Backwards compatibility: retain constant epsilon attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon0</span>

        <span class="c1"># Hysteresis ratio defines an inner dead‑band in which the</span>
        <span class="c1"># discontinuous robust term is suppressed.  A value in [0,1]</span>
        <span class="c1"># scales the nominal boundary layer ε; when |σ| &lt; hysteresis_ratio·ε0</span>
        <span class="c1"># the robust term is frozen to zero【967233543993377†L104-L115】.  This</span>
        <span class="c1"># further reduces chattering by avoiding high‑frequency switching</span>
        <span class="c1"># inside a small neighbourhood of the sliding surface.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hysteresis_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">hysteresis_ratio</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hysteresis_ratio</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hysteresis_ratio must be within [0,1]&quot;</span><span class="p">)</span>

        <span class="c1"># ---- Additional validation of SMC gains (F‑4.SMCDesign.2 / RC‑04) ----</span>
        <span class="c1"># Sliding‑mode theory requires strictly positive sliding‑surface and</span>
        <span class="c1"># switching gains and non‑negative derivative gain.  Validate each</span>
        <span class="c1"># gain here to catch misconfiguration early【Rhif2012†L563-L564】【ModelFreeSMC2018†L340-L345】.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="s2">&quot;k1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam1</span><span class="p">,</span> <span class="s2">&quot;lam1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam2</span><span class="p">,</span> <span class="s2">&quot;lam2&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">)</span>
        <span class="c1"># Allow derivative gain to be zero but not negative</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kd</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kd</span><span class="p">,</span> <span class="s2">&quot;kd&quot;</span><span class="p">,</span> <span class="n">allow_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">dynamics_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regularization</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span>
        <span class="c1"># Switching function selection</span>
        <span class="n">sm</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">switch_method</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;tanh&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;switch_method must be &#39;tanh&#39; or &#39;linear&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span> <span class="o">=</span> <span class="n">sm</span>

        <span class="c1"># Declare the dimensionality of the gain vector.  Exposing the</span>
        <span class="c1"># number of gains allows optimisers such as PSOTuner to infer</span>
        <span class="c1"># controller dimensionality without trial instantiation.  See</span>
        <span class="c1"># design review section 5 (PSO integration).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_gains</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>

        <span class="c1"># (C-007) Cache the model&#39;s singularity conditioning threshold if provided.</span>
        <span class="c1"># If unavailable, leave as None to allow regularization to rehabilitate borderline cases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cond_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="p">,</span> <span class="s2">&quot;p_model&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">p_model</span><span class="p">,</span> <span class="s2">&quot;singularity_cond_threshold&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cond_threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">p_model</span><span class="o">.</span><span class="n">singularity_cond_threshold</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="p">,</span> <span class="s2">&quot;params&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;singularity_cond_threshold&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cond_threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">singularity_cond_threshold</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cond_threshold</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Sliding surface uses only joint rates; cart input appears via B</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Configure logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># Store the controllability threshold used when computing the</span>
        <span class="c1"># equivalent control.  Earlier versions used the boundary layer</span>
        <span class="c1"># thickness `epsilon` as the cutoff for |L·M⁻¹·B|, conflating</span>
        <span class="c1"># chattering mitigation with controllability.</span>
        <span class="c1"># Here we allow the caller to specify a separate threshold via</span>
        <span class="c1"># ``controllability_threshold``.  If unspecified, a default of</span>
        <span class="c1"># 1e‑4 is used as a conservative lower bound on |L·M⁻¹·B|; too</span>
        <span class="c1"># small of a threshold can lead to numerical instabilities, while a</span>
        <span class="c1"># larger threshold needlessly suppresses the equivalent control.  See</span>
        <span class="c1"># Golub &amp; Van Loan for background on conditioning of linear systems.</span>
        <span class="k">if</span> <span class="n">controllability_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Scale the equivalent‑control threshold with the sum of switching gains.</span>
            <span class="c1"># Sliding‑mode theory states that the switching gain must exceed the</span>
            <span class="c1"># bound of system uncertainties plus a positive margin to guarantee</span>
            <span class="c1"># sliding【412237323761959†L496-L507】.  A threshold proportional to</span>
            <span class="c1"># (k1 + k2) avoids enabling the equivalent control when the system</span>
            <span class="c1"># is poorly controllable and adapts automatically when gains are</span>
            <span class="c1"># tuned.  The factor 0.05 was empirically chosen to provide a</span>
            <span class="c1"># conservative cutoff.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eq_threshold</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">controllability_threshold</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;controllability_threshold must be &gt; 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eq_threshold</span> <span class="o">=</span> <span class="n">val</span></div>


    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="c1"># Properties</span>
    <span class="c1"># ------------------------------------------------------------------</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the list of gains used by this controller.</span>

<span class="sd">        This property exposes the six control gains in the canonical order</span>
<span class="sd">        ``[k1, k2, lam1, lam2, K, kd]`` for external introspection.  The</span>
<span class="sd">        returned list is a shallow copy to prevent accidental mutation of</span>
<span class="sd">        the controller’s internal parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gains</span><span class="p">)</span>

<div class="viewcode-block" id="ClassicalSMC.initialize_state">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC.initialize_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;No internal state for classical SMC; returns an empty tuple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">()</span></div>


<div class="viewcode-block" id="ClassicalSMC.initialize_history">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC.initialize_history">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;No history tracked for classical SMC; returns an empty dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="ClassicalSMC.validate_gains">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC.validate_gains">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_gains</span><span class="p">(</span><span class="n">gains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that exactly six gains have been provided for the classical SMC.</span>

<span class="sd">        The classical sliding–mode controller uses six gains in the order</span>
<span class="sd">        ``[k1, k2, lam1, lam2, K, kd]``.  Any other length is considered</span>
<span class="sd">        misconfigured and results in a ``ValueError``.  This validator accepts</span>
<span class="sd">        any sequence or array-like input and coerces it to a one‑dimensional</span>
<span class="sd">        array of floats before verifying its length.  When coercion fails or</span>
<span class="sd">        the resulting array does not contain exactly six elements, a</span>
<span class="sd">        ``ValueError`` is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gains : Sequence[float] or array-like</span>
<span class="sd">            Sequence of gain values supplied during construction.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If ``gains`` is not convertible to a sequence of length six.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Attempt to coerce the gains into a flat NumPy array.  Any exception</span>
        <span class="c1"># indicates the input is not sequence-like or contains non-numeric</span>
        <span class="c1"># entries and should result in a validation error.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gains</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ClassicalSMC requires 6 gains: [k1, k2, lam1, lam2, K, kd]&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Ensure exactly six gains are provided</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ClassicalSMC requires 6 gains: [k1, k2, lam1, lam2, K, kd]&quot;</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sliding_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the sliding surface value, ``sigma``.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: State vector ``[x, theta1, theta2, xdot, dtheta1, dtheta2]``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The scalar sliding surface value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dtheta1</span><span class="p">,</span> <span class="n">dtheta2</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam1</span> <span class="o">*</span> <span class="n">theta1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam2</span> <span class="o">*</span> <span class="n">theta2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">*</span> <span class="n">dtheta1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">*</span> <span class="n">dtheta2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_equivalent_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the model-based equivalent control ``u_eq`` with enhanced robustness.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: State vector ``[x, theta1, theta2, xdot, dtheta1, dtheta2]``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The scalar equivalent control value, or 0.0 if computation is deemed unreliable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No dynamics model attached; return zero equivalent control.</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">q_dot</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="c1"># Attempt to obtain the physics matrices from the dynamics model.  If</span>
        <span class="c1"># this fails, fall back to purely switching control.  Broad</span>
        <span class="c1"># exceptions are caught here to avoid propagating unexpected errors</span>
        <span class="c1"># upstream.  When the model cannot provide the matrices, equivalent</span>
        <span class="c1"># control is set to zero.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">_compute_physics_matrices</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># Apply Tikhonov regularisation to ensure the inertia matrix is</span>
        <span class="c1"># invertible.  Adding a small positive diagonal term improves</span>
        <span class="c1"># conditioning and avoids the need for expensive singular value</span>
        <span class="c1"># decompositions.  This technique, sometimes called diagonal jitter,</span>
        <span class="c1"># guarantees that the matrix becomes positive definite and</span>
        <span class="c1"># invertible.</span>
        <span class="n">M_reg</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regularization</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Attempt to solve the linear system directly.  Use ``np.linalg.solve``</span>
        <span class="c1"># instead of a pseudo‑inverse to reduce computational overhead.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Compute the controllability scalar L @ M_reg^{-1} @ B.</span>
            <span class="n">Minv_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
            <span class="n">L_Minv_B</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_B</span><span class="p">)</span>
            <span class="c1"># Guard against uncontrollable configurations.  If the scalar</span>
            <span class="c1"># approaches zero the equivalent control becomes ill‑defined and</span>
            <span class="c1"># we conservatively return zero.  The threshold used here</span>
            <span class="c1"># (``self.eq_threshold``) is independent of the boundary‑layer</span>
            <span class="c1"># thickness ``epsilon``.  Earlier versions tied this cutoff</span>
            <span class="c1"># directly to the boundary layer, conflating chattering mitigation</span>
            <span class="c1"># with controllability.  Sliding‑mode literature notes that</span>
            <span class="c1"># widening the boundary layer reduces chattering but induces a</span>
            <span class="c1"># steady‑state error; therefore the</span>
            <span class="c1"># controllability threshold should be tuned separately.  When</span>
            <span class="c1"># |L⋅M⁻¹⋅B| &lt; ``self.eq_threshold`` the equivalent control is</span>
            <span class="c1"># disabled.</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L_Minv_B</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq_threshold</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>

            <span class="c1"># Compute the numerator of the equivalent control.  Handle</span>
            <span class="c1"># different shapes of the Coriolis matrix C gracefully: when C</span>
            <span class="c1"># is a matrix multiply by q_dot; when C is already a vector</span>
            <span class="c1"># treat it directly.  See the documentation for details.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">q_dot</span> <span class="o">+</span> <span class="n">G</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">G</span>
            <span class="n">Minv_rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
            <span class="n">term1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_rhs</span><span class="p">)</span>
            <span class="n">term2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam1</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam2</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">u_eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">term1</span> <span class="o">-</span> <span class="n">term2</span><span class="p">)</span> <span class="o">/</span> <span class="n">L_Minv_B</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="c1"># Inversion failed despite regularisation; treat as singular.</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># In earlier versions a diagnostic clamp and a tiny bias term were</span>
        <span class="c1"># introduced here.  Empirically clamping the equivalent control to</span>
        <span class="c1"># ±10×max_force and returning an epsilon when u_eq=0 obscured the</span>
        <span class="c1"># true magnitude of the model‑based term and hindered reproducibility.</span>
        <span class="c1"># Current guidance from sliding‑mode theory advocates computing</span>
        <span class="c1"># exactly the model‑based feedforward term and handling large values</span>
        <span class="c1"># via the main saturation at the end of ``compute_control``</span>
        <span class="c1">#.  Therefore we simply return the</span>
        <span class="c1"># computed u_eq without adding biases.  The subsequent saturation</span>
        <span class="c1"># stage in ``compute_control`` will limit the control action.</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_eq</span><span class="p">)</span>


<div class="viewcode-block" id="ClassicalSMC.compute_control">
<a class="viewcode-back" href="../../../api/controllers/classical_smc.html#src.controllers.classic_smc.ClassicalSMC.compute_control">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">state_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">history</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassicalSMCOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the control input for the classical SMC.</span>

<span class="sd">        The control law combines a model‑based equivalent term ``u_eq`` with</span>
<span class="sd">        a discontinuous (but smoothed) sliding‑mode term.  The robust term</span>
<span class="sd">        employs a saturation function within a boundary layer to approximate</span>
<span class="sd">        the sign function, which reduces chattering by replacing the infinite</span>
<span class="sd">        switching with a continuous control.  The</span>
<span class="sd">        total command is given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            u = u_{\\text{eq}} - K \\\\operatorname{sat}\\\\left(\\\\frac{\\\\sigma}{\\\\epsilon}\\\\right) - k_d \\\\, \\\\sigma,</span>

<span class="sd">        where ``sat`` is either ``tanh`` or a linear clip depending on</span>
<span class="sd">        ``switch_method``.</span>

<span class="sd">        After summing the terms the result is saturated to lie within</span>
<span class="sd">        ``[-max_force, +max_force]``.  Saturation of the final command limits</span>
<span class="sd">        actuator effort and ensures physical plausibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_surface</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># Adaptive boundary layer: compute a state‑dependent epsilon that</span>
        <span class="c1"># scales with the magnitude of the sliding variable.  This</span>
        <span class="c1"># continuous approximation reduces chattering while shrinking</span>
        <span class="c1"># towards zero near the sliding manifold【967233543993377†L104-L115】.</span>
        <span class="n">eps_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon1</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
        <span class="c1"># Apply hysteresis: when |sigma| lies within a small fraction of the</span>
        <span class="c1"># nominal boundary layer the robust term is suppressed.  This</span>
        <span class="c1"># dead‑band mitigates chattering by freezing the discontinuous</span>
        <span class="c1"># control inside the hysteresis band【967233543993377†L104-L115】.</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hysteresis_ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon0</span><span class="p">:</span>
            <span class="n">sat_sigma</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sat_sigma</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">eps_dyn</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span><span class="p">)</span>

        <span class="n">u_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_equivalent_control</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># Moderately clamp the equivalent control.  Unbounded model‑based</span>
        <span class="c1"># terms can exceed the actuator limits by orders of magnitude,</span>
        <span class="c1"># causing integrator wind‑up and excitation of unmodelled</span>
        <span class="c1"># dynamics.  Sliding‑mode design guidelines recommend limiting</span>
        <span class="c1"># the equivalent component relative to the maximum control</span>
        <span class="c1"># authority.  We saturate u_eq at ±5×max_force,</span>
        <span class="c1"># which preserves the fidelity of the model‑based term while</span>
        <span class="c1"># preventing pathological spikes.</span>
        <span class="n">max_eq</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_force</span>
        <span class="k">if</span> <span class="n">u_eq</span> <span class="o">&gt;</span> <span class="n">max_eq</span><span class="p">:</span>
            <span class="n">u_eq</span> <span class="o">=</span> <span class="n">max_eq</span>
        <span class="k">elif</span> <span class="n">u_eq</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_eq</span><span class="p">:</span>
            <span class="n">u_eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_eq</span>

        <span class="n">u_robust</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="n">sat_sigma</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">kd</span> <span class="o">*</span> <span class="n">sigma</span>

        <span class="c1"># Combine equivalent and robust terms and saturate final command</span>
        <span class="c1"># to the actuator limits.  The final saturation prevents</span>
        <span class="c1"># commanded torques/forces from exceeding the physical</span>
        <span class="c1"># capability of the actuator.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u_eq</span> <span class="o">+</span> <span class="n">u_robust</span>
        <span class="n">u_saturated</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_force</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_force</span><span class="p">))</span>

        <span class="c1"># Package the result into a named tuple.  Explicitly naming the</span>
        <span class="c1"># return fields clarifies the interface and reduces the risk of</span>
        <span class="c1"># misinterpretation.  The named tuple inherits</span>
        <span class="c1"># from ``tuple`` so existing code that expects a tuple</span>
        <span class="c1"># continues to function without modification.</span>
        <span class="k">return</span> <span class="n">ClassicalSMCOutput</span><span class="p">(</span><span class="n">u_saturated</span><span class="p">,</span> <span class="p">(),</span> <span class="n">history</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>
</div>

<span class="c1">#=======================================================================================\\\</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">DIP_SMC_PSO Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">src.controllers.classic_smc</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Research Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>